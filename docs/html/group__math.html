<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rc_mpu: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="strawsondesign_logo_text_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rc_mpu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__math.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Math</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a collection of functions for generating and implementing discrete SISO filters for arbitrary transfer functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__filter__t.html">rc_filter_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing configuration and state of a SISO filter.  <a href="structrc__filter__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing state of a ringbuffer and pointer to dynamically allocated memory.  <a href="structrc__ringbuf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__vector__t.html">rc_vector_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents.  <a href="structrc__vector__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab41dce761fc5db225d8cc88f9b131a66"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab41dce761fc5db225d8cc88f9b131a66">rc_filter_t</a></td></tr>
<tr class="memdesc:gab41dce761fc5db225d8cc88f9b131a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing configuration and state of a SISO filter.  <a href="#gab41dce761fc5db225d8cc88f9b131a66">More...</a><br /></td></tr>
<tr class="separator:gab41dce761fc5db225d8cc88f9b131a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc2f47a5af64e67792773720eb9b978"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaffc2f47a5af64e67792773720eb9b978">rc_ringbuf_t</a></td></tr>
<tr class="memdesc:gaffc2f47a5af64e67792773720eb9b978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing state of a ringbuffer and pointer to dynamically allocated memory.  <a href="#gaffc2f47a5af64e67792773720eb9b978">More...</a><br /></td></tr>
<tr class="separator:gaffc2f47a5af64e67792773720eb9b978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356f39688934d6424182bfb27d60c5e1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga356f39688934d6424182bfb27d60c5e1">rc_vector_t</a></td></tr>
<tr class="memdesc:ga356f39688934d6424182bfb27d60c5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents.  <a href="#ga356f39688934d6424182bfb27d60c5e1">More...</a><br /></td></tr>
<tr class="separator:ga356f39688934d6424182bfb27d60c5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c47037413178daf5f6ce513a0587cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7c47037413178daf5f6ce513a0587cb6">rc_filter_empty</a> ()</td></tr>
<tr class="memdesc:ga7c47037413178daf5f6ce513a0587cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Critical function for initializing <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> structs.  <a href="#ga7c47037413178daf5f6ce513a0587cb6">More...</a><br /></td></tr>
<tr class="separator:ga7c47037413178daf5f6ce513a0587cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1464a0f94a17f406598456f43e1e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4e1464a0f94a17f406598456f43e1e84">rc_filter_alloc</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> num, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> den, float dt)</td></tr>
<tr class="memdesc:ga4e1464a0f94a17f406598456f43e1e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients provided in vectors num and den.  <a href="#ga4e1464a0f94a17f406598456f43e1e84">More...</a><br /></td></tr>
<tr class="separator:ga4e1464a0f94a17f406598456f43e1e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133af9fe414b88fafedbfb8bf93c7d09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga133af9fe414b88fafedbfb8bf93c7d09">rc_filter_alloc_from_arrays</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt, float *num, int numlen, float *den, int denlen)</td></tr>
<tr class="memdesc:ga133af9fe414b88fafedbfb8bf93c7d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__math.html#ga4e1464a0f94a17f406598456f43e1e84" title="Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients pro...">rc_filter_alloc()</a>, but takes arrays for the numerator and denominator coefficients instead of vectors.  <a href="#ga133af9fe414b88fafedbfb8bf93c7d09">More...</a><br /></td></tr>
<tr class="separator:ga133af9fe414b88fafedbfb8bf93c7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b1abf89fc93d78bdcbd3b08842c468"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gad7b1abf89fc93d78bdcbd3b08842c468">rc_filter_free</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f)</td></tr>
<tr class="memdesc:gad7b1abf89fc93d78bdcbd3b08842c468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated by a filter's buffers and coefficient vectors. Also resets all filter properties back to 0.  <a href="#gad7b1abf89fc93d78bdcbd3b08842c468">More...</a><br /></td></tr>
<tr class="separator:gad7b1abf89fc93d78bdcbd3b08842c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6dff1f36b8e4ef7db264dd2332d3866"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac6dff1f36b8e4ef7db264dd2332d3866">rc_filter_print</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> f)</td></tr>
<tr class="memdesc:gac6dff1f36b8e4ef7db264dd2332d3866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the transfer function and other statistic of a filter to the screen.  <a href="#gac6dff1f36b8e4ef7db264dd2332d3866">More...</a><br /></td></tr>
<tr class="separator:gac6dff1f36b8e4ef7db264dd2332d3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6dcce7fda87d140a7a9793546ff3d6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab6dcce7fda87d140a7a9793546ff3d6e">rc_filter_march</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float new_input)</td></tr>
<tr class="memdesc:gab6dcce7fda87d140a7a9793546ff3d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">March a filter forward one step with new input provided as an argument.  <a href="#gab6dcce7fda87d140a7a9793546ff3d6e">More...</a><br /></td></tr>
<tr class="separator:gab6dcce7fda87d140a7a9793546ff3d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4544fbb000ae45030f1cfd0f0aaff311"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4544fbb000ae45030f1cfd0f0aaff311">rc_filter_reset</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f)</td></tr>
<tr class="memdesc:ga4544fbb000ae45030f1cfd0f0aaff311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all previous inputs and outputs to 0. Also resets the step counter &amp; saturation flag.  <a href="#ga4544fbb000ae45030f1cfd0f0aaff311">More...</a><br /></td></tr>
<tr class="separator:ga4544fbb000ae45030f1cfd0f0aaff311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df0afb5d7700221d624237e22c12649"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2df0afb5d7700221d624237e22c12649">rc_filter_enable_saturation</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float min, float max)</td></tr>
<tr class="memdesc:ga2df0afb5d7700221d624237e22c12649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables saturation between bounds min and max.  <a href="#ga2df0afb5d7700221d624237e22c12649">More...</a><br /></td></tr>
<tr class="separator:ga2df0afb5d7700221d624237e22c12649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa670c91acf8c6d633938ea51905a0ab7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa670c91acf8c6d633938ea51905a0ab7">rc_filter_get_saturation_flag</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f)</td></tr>
<tr class="memdesc:gaa670c91acf8c6d633938ea51905a0ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the filter saturated the last time step.  <a href="#gaa670c91acf8c6d633938ea51905a0ab7">More...</a><br /></td></tr>
<tr class="separator:gaa670c91acf8c6d633938ea51905a0ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cfc46c70bf2de23b18a22ebb216d16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gad1cfc46c70bf2de23b18a22ebb216d16">rc_filter_enable_soft_start</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float seconds)</td></tr>
<tr class="memdesc:gad1cfc46c70bf2de23b18a22ebb216d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables soft start functionality where the output bound is gradually opened linearly from 0 to the normal saturation range.  <a href="#gad1cfc46c70bf2de23b18a22ebb216d16">More...</a><br /></td></tr>
<tr class="separator:gad1cfc46c70bf2de23b18a22ebb216d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04ac8f24db32d685a28a2281ab143cf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf04ac8f24db32d685a28a2281ab143cf">rc_filter_previous_input</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int steps)</td></tr>
<tr class="memdesc:gaf04ac8f24db32d685a28a2281ab143cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input 'steps' back in time. Steps=0 returns most recent input.  <a href="#gaf04ac8f24db32d685a28a2281ab143cf">More...</a><br /></td></tr>
<tr class="separator:gaf04ac8f24db32d685a28a2281ab143cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd76dd4d434632b69ebeef7dffc104d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaccd76dd4d434632b69ebeef7dffc104d">rc_filter_previous_output</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int steps)</td></tr>
<tr class="memdesc:gaccd76dd4d434632b69ebeef7dffc104d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output 'steps' back in time. Steps = 0 returns most recent output.  <a href="#gaccd76dd4d434632b69ebeef7dffc104d">More...</a><br /></td></tr>
<tr class="separator:gaccd76dd4d434632b69ebeef7dffc104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed432398b3edd76018844b657c18b6c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaed432398b3edd76018844b657c18b6c9">rc_filter_prefill_inputs</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float in)</td></tr>
<tr class="memdesc:gaed432398b3edd76018844b657c18b6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills all previous inputs to the filter as if they had been equal to 'in'.  <a href="#gaed432398b3edd76018844b657c18b6c9">More...</a><br /></td></tr>
<tr class="separator:gaed432398b3edd76018844b657c18b6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e465ba6c68031669d1832ab5a11ca22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9e465ba6c68031669d1832ab5a11ca22">rc_filter_prefill_outputs</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float out)</td></tr>
<tr class="memdesc:ga9e465ba6c68031669d1832ab5a11ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills all previous outputs of the filter as if they had been equal to 'out'.  <a href="#ga9e465ba6c68031669d1832ab5a11ca22">More...</a><br /></td></tr>
<tr class="separator:ga9e465ba6c68031669d1832ab5a11ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fed5adaabaa85e248045185f89f4cf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6fed5adaabaa85e248045185f89f4cf8">rc_filter_multiply</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> f1, <a class="el" href="structrc__filter__t.html">rc_filter_t</a> f2, <a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f3)</td></tr>
<tr class="memdesc:ga6fed5adaabaa85e248045185f89f4cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new filter f3 by multiplying f1*f2.  <a href="#ga6fed5adaabaa85e248045185f89f4cf8">More...</a><br /></td></tr>
<tr class="separator:ga6fed5adaabaa85e248045185f89f4cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8bd927ae75b530b5de9c9020986463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga8a8bd927ae75b530b5de9c9020986463">rc_filter_c2d_tustin</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> num, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> den, float dt, float w)</td></tr>
<tr class="memdesc:ga8a8bd927ae75b530b5de9c9020986463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a discrete time filter with similar dynamics to a provided continuous time transfer function using tustin's approximation with prewarping about a frequency of interest 'w' in radians per second.  <a href="#ga8a8bd927ae75b530b5de9c9020986463">More...</a><br /></td></tr>
<tr class="separator:ga8a8bd927ae75b530b5de9c9020986463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e152f66ea01c7516f95b63bcf1480d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9e152f66ea01c7516f95b63bcf1480d0">rc_filter_first_order_lowpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt, float tc)</td></tr>
<tr class="memdesc:ga9e152f66ea01c7516f95b63bcf1480d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a first order low pass filter.  <a href="#ga9e152f66ea01c7516f95b63bcf1480d0">More...</a><br /></td></tr>
<tr class="separator:ga9e152f66ea01c7516f95b63bcf1480d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda58e96a2784f113d3ad8339216eeae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafda58e96a2784f113d3ad8339216eeae">rc_filter_first_order_highpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt, float tc)</td></tr>
<tr class="memdesc:gafda58e96a2784f113d3ad8339216eeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a first order high pass filter.  <a href="#gafda58e96a2784f113d3ad8339216eeae">More...</a><br /></td></tr>
<tr class="separator:gafda58e96a2784f113d3ad8339216eeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7cbcc1ed92e160992862723167e5c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa7cbcc1ed92e160992862723167e5c95">rc_filter_butterworth_lowpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int order, float dt, float wc)</td></tr>
<tr class="memdesc:gaa7cbcc1ed92e160992862723167e5c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Butterworth low pass filter of specified order and cutoff frequency.  <a href="#gaa7cbcc1ed92e160992862723167e5c95">More...</a><br /></td></tr>
<tr class="separator:gaa7cbcc1ed92e160992862723167e5c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1cca3007150600687be7524c378e19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaca1cca3007150600687be7524c378e19">rc_filter_butterworth_highpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int order, float dt, float wc)</td></tr>
<tr class="memdesc:gaca1cca3007150600687be7524c378e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Butterworth high pass filter of specified order and cutoff frequency.  <a href="#gaca1cca3007150600687be7524c378e19">More...</a><br /></td></tr>
<tr class="separator:gaca1cca3007150600687be7524c378e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6071427fe1e733ec979c1ffdad462068"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6071427fe1e733ec979c1ffdad462068">rc_filter_moving_average</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int samples, int dt)</td></tr>
<tr class="memdesc:ga6071427fe1e733ec979c1ffdad462068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a FIR moving average filter that averages over specified number of samples.  <a href="#ga6071427fe1e733ec979c1ffdad462068">More...</a><br /></td></tr>
<tr class="separator:ga6071427fe1e733ec979c1ffdad462068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10997e97d1d8be64fdb82542a5372c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac10997e97d1d8be64fdb82542a5372c1">rc_filter_integrator</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt)</td></tr>
<tr class="memdesc:gac10997e97d1d8be64fdb82542a5372c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a first order integrator.  <a href="#gac10997e97d1d8be64fdb82542a5372c1">More...</a><br /></td></tr>
<tr class="separator:gac10997e97d1d8be64fdb82542a5372c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867da96db2d48e580ca236e104e5e22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga867da96db2d48e580ca236e104e5e22b">rc_filter_double_integrator</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt)</td></tr>
<tr class="memdesc:ga867da96db2d48e580ca236e104e5e22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a second order double integrator.  <a href="#ga867da96db2d48e580ca236e104e5e22b">More...</a><br /></td></tr>
<tr class="separator:ga867da96db2d48e580ca236e104e5e22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbdcb4d5a38d6bbe78e35528d40c3f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafdbdcb4d5a38d6bbe78e35528d40c3f7">rc_filter_pid</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float kp, float ki, float kd, float Tf, float dt)</td></tr>
<tr class="memdesc:gafdbdcb4d5a38d6bbe78e35528d40c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a discrete-time implementation of a parallel PID controller with high-frequency rolloff.  <a href="#gafdbdcb4d5a38d6bbe78e35528d40c3f7">More...</a><br /></td></tr>
<tr class="separator:gafdbdcb4d5a38d6bbe78e35528d40c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760c0174bed236a311471ea303d43a0b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga760c0174bed236a311471ea303d43a0b">rc_get_random_float</a> ()</td></tr>
<tr class="memdesc:ga760c0174bed236a311471ea303d43a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random floating point number between -1 and 1.  <a href="#ga760c0174bed236a311471ea303d43a0b">More...</a><br /></td></tr>
<tr class="separator:ga760c0174bed236a311471ea303d43a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a283b77c5d02020aee8188053d9139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga10a283b77c5d02020aee8188053d9139">rc_get_random_double</a> ()</td></tr>
<tr class="memdesc:ga10a283b77c5d02020aee8188053d9139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double-precision floating point number between -1 and 1.  <a href="#ga10a283b77c5d02020aee8188053d9139">More...</a><br /></td></tr>
<tr class="separator:ga10a283b77c5d02020aee8188053d9139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2977f271b49fb61945c338cb37d56731"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2977f271b49fb61945c338cb37d56731">rc_saturate_float</a> (float *val, float min, float max)</td></tr>
<tr class="memdesc:ga2977f271b49fb61945c338cb37d56731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies val to be bounded between between min and max.  <a href="#ga2977f271b49fb61945c338cb37d56731">More...</a><br /></td></tr>
<tr class="separator:ga2977f271b49fb61945c338cb37d56731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db783667dde7eb053dd7ac01bf6f9d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0db783667dde7eb053dd7ac01bf6f9d9">rc_saturate_double</a> (double *val, double min, double max)</td></tr>
<tr class="memdesc:ga0db783667dde7eb053dd7ac01bf6f9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies val to be bounded between between min and max.  <a href="#ga0db783667dde7eb053dd7ac01bf6f9d9">More...</a><br /></td></tr>
<tr class="separator:ga0db783667dde7eb053dd7ac01bf6f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d2b3a3b9405b3d01c2be85ef2b731b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga99d2b3a3b9405b3d01c2be85ef2b731b">rc_poly_print</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga99d2b3a3b9405b3d01c2be85ef2b731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a polynomial in human-readable format in one line.  <a href="#ga99d2b3a3b9405b3d01c2be85ef2b731b">More...</a><br /></td></tr>
<tr class="separator:ga99d2b3a3b9405b3d01c2be85ef2b731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ec56458baca9a38093d74a444513fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0ec56458baca9a38093d74a444513fdd">rc_poly_conv</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga0ec56458baca9a38093d74a444513fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolutes the polynomials a&amp;b and places the result in vector c.  <a href="#ga0ec56458baca9a38093d74a444513fdd">More...</a><br /></td></tr>
<tr class="separator:ga0ec56458baca9a38093d74a444513fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ebd34a90a744787f2f2becaaeada2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae1ebd34a90a744787f2f2becaaeada2f">rc_poly_power</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, int n, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:gae1ebd34a90a744787f2f2becaaeada2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a polynomial a to itself n times where n is greater than or equal to 0.  <a href="#gae1ebd34a90a744787f2f2becaaeada2f">More...</a><br /></td></tr>
<tr class="separator:gae1ebd34a90a744787f2f2becaaeada2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb6fa5439346ca03f4404ba65f753d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gabfb6fa5439346ca03f4404ba65f753d4">rc_poly_add</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:gabfb6fa5439346ca03f4404ba65f753d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two polynomials a&amp;b with right justification and place the result in c.  <a href="#gabfb6fa5439346ca03f4404ba65f753d4">More...</a><br /></td></tr>
<tr class="separator:gabfb6fa5439346ca03f4404ba65f753d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8ede505de3ba460edfb4c687fed29f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7a8ede505de3ba460edfb4c687fed29f">rc_poly_add_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b)</td></tr>
<tr class="memdesc:ga7a8ede505de3ba460edfb4c687fed29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds polynomials a&amp;b with right justification.  <a href="#ga7a8ede505de3ba460edfb4c687fed29f">More...</a><br /></td></tr>
<tr class="separator:ga7a8ede505de3ba460edfb4c687fed29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9">rc_poly_subtract</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two polynomials a-b with right justification and places the result in c.  <a href="#ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9">More...</a><br /></td></tr>
<tr class="separator:ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a9d83172575f86fa60622d57c816e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga50a9d83172575f86fa60622d57c816e4">rc_poly_subtract_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b)</td></tr>
<tr class="memdesc:ga50a9d83172575f86fa60622d57c816e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts b from a with right justification.  <a href="#ga50a9d83172575f86fa60622d57c816e4">More...</a><br /></td></tr>
<tr class="separator:ga50a9d83172575f86fa60622d57c816e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbae3c7a60135300ec4b7765eb956bbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gabbae3c7a60135300ec4b7765eb956bbe">rc_poly_differentiate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, int d, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:gabbae3c7a60135300ec4b7765eb956bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dth derivative of the polynomial a and places the result in vector b.  <a href="#gabbae3c7a60135300ec4b7765eb956bbe">More...</a><br /></td></tr>
<tr class="separator:gabbae3c7a60135300ec4b7765eb956bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa30b88e21671748ce4008e25dc6f200d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa30b88e21671748ce4008e25dc6f200d">rc_poly_divide</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> n, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> d, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *div, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *rem)</td></tr>
<tr class="memdesc:gaa30b88e21671748ce4008e25dc6f200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides denominator d into numerator n. The remainder is placed into vector rem and the divisor is placed into vector div.  <a href="#gaa30b88e21671748ce4008e25dc6f200d">More...</a><br /></td></tr>
<tr class="separator:gaa30b88e21671748ce4008e25dc6f200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aa9ad027e326f7953c7820d860179b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa8aa9ad027e326f7953c7820d860179b">rc_poly_butter</a> (int N, float wc, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:gaa8aa9ad027e326f7953c7820d860179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates coefficients for continuous-time Butterworth polynomial of order N and cutoff wc (rad/s) and places them in vector b.  <a href="#gaa8aa9ad027e326f7953c7820d860179b">More...</a><br /></td></tr>
<tr class="separator:gaa8aa9ad027e326f7953c7820d860179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef65d4b842f1bb9effcb4a117d64859"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafef65d4b842f1bb9effcb4a117d64859">rc_quaternion_norm</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q)</td></tr>
<tr class="memdesc:gafef65d4b842f1bb9effcb4a117d64859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a quaternion vector by finding its 2-norm.  <a href="#gafef65d4b842f1bb9effcb4a117d64859">More...</a><br /></td></tr>
<tr class="separator:gafef65d4b842f1bb9effcb4a117d64859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae93ebf3650d5ab34e4739b8bbd9960"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7ae93ebf3650d5ab34e4739b8bbd9960">rc_quaternion_norm_array</a> (float q[4])</td></tr>
<tr class="memdesc:ga7ae93ebf3650d5ab34e4739b8bbd9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a quaternion vector by finding its 2-norm.  <a href="#ga7ae93ebf3650d5ab34e4739b8bbd9960">More...</a><br /></td></tr>
<tr class="separator:ga7ae93ebf3650d5ab34e4739b8bbd9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e42cb59e9789b957067dbf27f011dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa4e42cb59e9789b957067dbf27f011dd">rc_normalize_quaternion</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *q)</td></tr>
<tr class="memdesc:gaa4e42cb59e9789b957067dbf27f011dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion in-place to have length 1.0.  <a href="#gaa4e42cb59e9789b957067dbf27f011dd">More...</a><br /></td></tr>
<tr class="separator:gaa4e42cb59e9789b957067dbf27f011dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542d62f500c6a0b29aa6ab0afc9d4115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga542d62f500c6a0b29aa6ab0afc9d4115">rc_normalize_quaternion_array</a> (float q[4])</td></tr>
<tr class="memdesc:ga542d62f500c6a0b29aa6ab0afc9d4115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion in-place to have length 1.0.  <a href="#ga542d62f500c6a0b29aa6ab0afc9d4115">More...</a><br /></td></tr>
<tr class="separator:ga542d62f500c6a0b29aa6ab0afc9d4115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563e33eda488bf7b8676bf6104905754"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga563e33eda488bf7b8676bf6104905754">rc_quaternion_to_tb</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *tb)</td></tr>
<tr class="memdesc:ga563e33eda488bf7b8676bf6104905754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x).  <a href="#ga563e33eda488bf7b8676bf6104905754">More...</a><br /></td></tr>
<tr class="separator:ga563e33eda488bf7b8676bf6104905754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51dde57b0eca9f3b5a6b977ea65cc660"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga51dde57b0eca9f3b5a6b977ea65cc660">rc_quaternion_to_tb_array</a> (float q[4], float tb[3])</td></tr>
<tr class="memdesc:ga51dde57b0eca9f3b5a6b977ea65cc660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x).  <a href="#ga51dde57b0eca9f3b5a6b977ea65cc660">More...</a><br /></td></tr>
<tr class="separator:ga51dde57b0eca9f3b5a6b977ea65cc660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa85c68c560d6ace81e3cf2b02be92e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5aa85c68c560d6ace81e3cf2b02be92e">rc_tb_to_quaternion</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> tb, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *q)</td></tr>
<tr class="separator:ga5aa85c68c560d6ace81e3cf2b02be92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcaf3f4a38427c88ef3df9ef66bfa7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gadcaf3f4a38427c88ef3df9ef66bfa7c5">rc_tb_to_quaternion_array</a> (float tb[3], float q[4])</td></tr>
<tr class="separator:gadcaf3f4a38427c88ef3df9ef66bfa7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ff0571c5b14a9c9866ccf659ede2be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae6ff0571c5b14a9c9866ccf659ede2be">rc_quaternion_conjugate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="separator:gae6ff0571c5b14a9c9866ccf659ede2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6a22394f69065da0db6814ab4cc809"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2f6a22394f69065da0db6814ab4cc809">rc_quaternion_conjugate_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *q)</td></tr>
<tr class="separator:ga2f6a22394f69065da0db6814ab4cc809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24c75817dfbb514dbc057c675a6831b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga24c75817dfbb514dbc057c675a6831b1">rc_quaternion_conjugate_array</a> (float q[4], float c[4])</td></tr>
<tr class="separator:ga24c75817dfbb514dbc057c675a6831b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76abb7da3646cb6200ac7743761298d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga76abb7da3646cb6200ac7743761298d0">rc_quaternion_conjugate_array_inplace</a> (float q[4])</td></tr>
<tr class="separator:ga76abb7da3646cb6200ac7743761298d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979a8b5919c153ccdd9cf1611bb5da95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga979a8b5919c153ccdd9cf1611bb5da95">rc_quaternion_imaginary_part</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *img)</td></tr>
<tr class="separator:ga979a8b5919c153ccdd9cf1611bb5da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f6fc81fa687d8341bd78dff1e8357e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga69f6fc81fa687d8341bd78dff1e8357e">rc_quaternion_multiply</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="separator:ga69f6fc81fa687d8341bd78dff1e8357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e6282f73d7e338c0e3d008131d49ef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4e6282f73d7e338c0e3d008131d49ef7">rc_quaternion_multiply_array</a> (float a[4], float b[4], float c[4])</td></tr>
<tr class="separator:ga4e6282f73d7e338c0e3d008131d49ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3354c12cc243ed0610cf00099f74bab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa3354c12cc243ed0610cf00099f74bab">rc_rotate_quaternion</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> q)</td></tr>
<tr class="separator:gaa3354c12cc243ed0610cf00099f74bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd6b10bac88cd15045324b029749b562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gadd6b10bac88cd15045324b029749b562">rc_rotate_quaternion_array</a> (float p[4], float q[4])</td></tr>
<tr class="separator:gadd6b10bac88cd15045324b029749b562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dcacf759d45c9c92782253338c1269b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4dcacf759d45c9c92782253338c1269b">rc_quaternion_rotate_vector</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> q)</td></tr>
<tr class="separator:ga4dcacf759d45c9c92782253338c1269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace7b5ee210fb16ac4153cb3b223dc18e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gace7b5ee210fb16ac4153cb3b223dc18e">rc_quaternion_rotate_vector_array</a> (float v[3], float q[4])</td></tr>
<tr class="separator:gace7b5ee210fb16ac4153cb3b223dc18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga1fbbeb418f6e71f2eefd7dc57c9bfbc8">rc_quaternion_to_rotation_matrix</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *m)</td></tr>
<tr class="separator:ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa154c6584a2367b07cc13fea3f9458e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa154c6584a2367b07cc13fea3f9458e9">rc_ringbuf_empty</a> ()</td></tr>
<tr class="memdesc:gaa154c6584a2367b07cc13fea3f9458e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct which is completely zero'd out with no memory allocated for it.  <a href="#gaa154c6584a2367b07cc13fea3f9458e9">More...</a><br /></td></tr>
<tr class="separator:gaa154c6584a2367b07cc13fea3f9458e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081c474a7a3e607a73080f5b7d6de94c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga081c474a7a3e607a73080f5b7d6de94c">rc_ringbuf_alloc</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf, int size)</td></tr>
<tr class="memdesc:ga081c474a7a3e607a73080f5b7d6de94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for a ring buffer and initializes an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct.  <a href="#ga081c474a7a3e607a73080f5b7d6de94c">More...</a><br /></td></tr>
<tr class="separator:ga081c474a7a3e607a73080f5b7d6de94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc048f71fcf6c35008c4a42a4c646d79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gacc048f71fcf6c35008c4a42a4c646d79">rc_ringbuf_free</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf)</td></tr>
<tr class="memdesc:gacc048f71fcf6c35008c4a42a4c646d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for buffer buf.  <a href="#gacc048f71fcf6c35008c4a42a4c646d79">More...</a><br /></td></tr>
<tr class="separator:gacc048f71fcf6c35008c4a42a4c646d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9da5cc641aed10a6212df49f72669c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa9da5cc641aed10a6212df49f72669c3">rc_ringbuf_reset</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf)</td></tr>
<tr class="memdesc:gaa9da5cc641aed10a6212df49f72669c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the buffer to 0.0f and sets the buffer index back to 0.  <a href="#gaa9da5cc641aed10a6212df49f72669c3">More...</a><br /></td></tr>
<tr class="separator:gaa9da5cc641aed10a6212df49f72669c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c20b9aaa891eb1feb74c76e5e1aa3b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5c20b9aaa891eb1feb74c76e5e1aa3b2">rc_ringbuf_insert</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf, float val)</td></tr>
<tr class="memdesc:ga5c20b9aaa891eb1feb74c76e5e1aa3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a new float into the ring buffer and updates the index accordingly.  <a href="#ga5c20b9aaa891eb1feb74c76e5e1aa3b2">More...</a><br /></td></tr>
<tr class="separator:ga5c20b9aaa891eb1feb74c76e5e1aa3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e03c7c74b16d77515e71effae69132"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga28e03c7c74b16d77515e71effae69132">rc_ringbuf_get_value</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf, int position)</td></tr>
<tr class="memdesc:ga28e03c7c74b16d77515e71effae69132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the float which is 'position' steps behind the last value added to the buffer.  <a href="#ga28e03c7c74b16d77515e71effae69132">More...</a><br /></td></tr>
<tr class="separator:ga28e03c7c74b16d77515e71effae69132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a7ebb9b092f24f94a65eae283f4cd2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac3a7ebb9b092f24f94a65eae283f4cd2">rc_ringbuf_std_dev</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> buf)</td></tr>
<tr class="memdesc:gac3a7ebb9b092f24f94a65eae283f4cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of all values in the ring buffer.  <a href="#gac3a7ebb9b092f24f94a65eae283f4cd2">More...</a><br /></td></tr>
<tr class="separator:gac3a7ebb9b092f24f94a65eae283f4cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga033739cf97c12aa0d22e2a38cf658aa7">rc_vector_empty</a> ()</td></tr>
<tr class="memdesc:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0.  <a href="#ga033739cf97c12aa0d22e2a38cf658aa7">More...</a><br /></td></tr>
<tr class="separator:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11722701079a6c31a88c1b2b5535c034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga11722701079a6c31a88c1b2b5535c034">rc_vector_alloc</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga11722701079a6c31a88c1b2b5535c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for vector v to have specified length.  <a href="#ga11722701079a6c31a88c1b2b5535c034">More...</a><br /></td></tr>
<tr class="separator:ga11722701079a6c31a88c1b2b5535c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">rc_vector_free</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v)</td></tr>
<tr class="memdesc:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for vector v.  <a href="#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">More...</a><br /></td></tr>
<tr class="separator:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaaf406d1cf903d34a2fb175d947b7b9fd">rc_vector_zeros</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with zeros.  <a href="#gaaf406d1cf903d34a2fb175d947b7b9fd">More...</a><br /></td></tr>
<tr class="separator:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c2070da0f5b606113068dabcf64606"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga93c2070da0f5b606113068dabcf64606">rc_vector_ones</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga93c2070da0f5b606113068dabcf64606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with ones.  <a href="#ga93c2070da0f5b606113068dabcf64606">More...</a><br /></td></tr>
<tr class="separator:ga93c2070da0f5b606113068dabcf64606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b0bc1f274f79017342393a2cf4c768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga61b0bc1f274f79017342393a2cf4c768">rc_vector_random</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga61b0bc1f274f79017342393a2cf4c768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with random numbers between -1.0 and 1.0.  <a href="#ga61b0bc1f274f79017342393a2cf4c768">More...</a><br /></td></tr>
<tr class="separator:ga61b0bc1f274f79017342393a2cf4c768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26ea389839dc7cae224a3709316db03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab26ea389839dc7cae224a3709316db03">rc_vector_fibonnaci</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:gab26ea389839dc7cae224a3709316db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with Fibonnaci sequence.  <a href="#gab26ea389839dc7cae224a3709316db03">More...</a><br /></td></tr>
<tr class="separator:gab26ea389839dc7cae224a3709316db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga31a8a6926c3eeabe915ea943976a2e0e">rc_vector_from_array</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, float *ptr, int length)</td></tr>
<tr class="memdesc:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and populates with values from specified array ptr.  <a href="#ga31a8a6926c3eeabe915ea943976a2e0e">More...</a><br /></td></tr>
<tr class="separator:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aade05352c44f0eed9835a2e555254f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5aade05352c44f0eed9835a2e555254f">rc_vector_duplicate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:ga5aade05352c44f0eed9835a2e555254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the contents of vector a and into a new vector b.  <a href="#ga5aade05352c44f0eed9835a2e555254f">More...</a><br /></td></tr>
<tr class="separator:ga5aade05352c44f0eed9835a2e555254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd986c3f1759de97760c2e65245fc45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafbd986c3f1759de97760c2e65245fc45">rc_vector_print</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:gafbd986c3f1759de97760c2e65245fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to stdout the contents of vector v in one line.  <a href="#gafbd986c3f1759de97760c2e65245fc45">More...</a><br /></td></tr>
<tr class="separator:gafbd986c3f1759de97760c2e65245fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea0298241c1b0207aea04cd331041d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6ea0298241c1b0207aea04cd331041d9">rc_vector_print_sci</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga6ea0298241c1b0207aea04cd331041d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to stdout the contents of vector v in one line.  <a href="#ga6ea0298241c1b0207aea04cd331041d9">More...</a><br /></td></tr>
<tr class="separator:ga6ea0298241c1b0207aea04cd331041d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a9764a948a56fae6d5f1897edf8562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac2a9764a948a56fae6d5f1897edf8562">rc_vector_times_scalar</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, float s)</td></tr>
<tr class="memdesc:gac2a9764a948a56fae6d5f1897edf8562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies every entry in vector v by scalar s.  <a href="#gac2a9764a948a56fae6d5f1897edf8562">More...</a><br /></td></tr>
<tr class="separator:gac2a9764a948a56fae6d5f1897edf8562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5553a660876a1576c0bd226e49608e68"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5553a660876a1576c0bd226e49608e68">rc_vector_norm</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, float p)</td></tr>
<tr class="memdesc:ga5553a660876a1576c0bd226e49608e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p is any positive real value.  <a href="#ga5553a660876a1576c0bd226e49608e68">More...</a><br /></td></tr>
<tr class="separator:ga5553a660876a1576c0bd226e49608e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4b086af44400fa2fa56af2618bfe81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga3e4b086af44400fa2fa56af2618bfe81">rc_vector_max</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga3e4b086af44400fa2fa56af2618bfe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the maximum value in v.  <a href="#ga3e4b086af44400fa2fa56af2618bfe81">More...</a><br /></td></tr>
<tr class="separator:ga3e4b086af44400fa2fa56af2618bfe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5cf5dee22ee0807725e86463b3cb415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf5cf5dee22ee0807725e86463b3cb415">rc_vector_min</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:gaf5cf5dee22ee0807725e86463b3cb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the minimum value in v.  <a href="#gaf5cf5dee22ee0807725e86463b3cb415">More...</a><br /></td></tr>
<tr class="separator:gaf5cf5dee22ee0807725e86463b3cb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc3db26b59dc0454321820bfd8c9384"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0cc3db26b59dc0454321820bfd8c9384">rc_vector_std_dev</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga0cc3db26b59dc0454321820bfd8c9384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of the values in a vector.  <a href="#ga0cc3db26b59dc0454321820bfd8c9384">More...</a><br /></td></tr>
<tr class="separator:ga0cc3db26b59dc0454321820bfd8c9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5787bffdc4620a44699a71cd496e7187"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5787bffdc4620a44699a71cd496e7187">rc_vector_mean</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga5787bffdc4620a44699a71cd496e7187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean (average) of all values in vector v or -1.0f on error.  <a href="#ga5787bffdc4620a44699a71cd496e7187">More...</a><br /></td></tr>
<tr class="separator:ga5787bffdc4620a44699a71cd496e7187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9d6baef58e77a3f6f17cd76d3967dcce">rc_vector_projection</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> e, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p)</td></tr>
<tr class="memdesc:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector p with the projection of vector v onto e.  <a href="#ga9d6baef58e77a3f6f17cd76d3967dcce">More...</a><br /></td></tr>
<tr class="separator:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca02db03974e50fa834e3512415991bb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaca02db03974e50fa834e3512415991bb">rc_vector_dot_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2)</td></tr>
<tr class="memdesc:gaca02db03974e50fa834e3512415991bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two equal-length vectors.  <a href="#gaca02db03974e50fa834e3512415991bb">More...</a><br /></td></tr>
<tr class="separator:gaca02db03974e50fa834e3512415991bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">rc_vector_cross_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p)</td></tr>
<tr class="memdesc:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross-product of two vectors, each of length 3.  <a href="#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">More...</a><br /></td></tr>
<tr class="separator:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8a002edae139b24bde39eff021cf8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2c8a002edae139b24bde39eff021cf8e">rc_vector_sum</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *s)</td></tr>
<tr class="memdesc:ga2c8a002edae139b24bde39eff021cf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector s with the sum of vectors v1 and v2.  <a href="#ga2c8a002edae139b24bde39eff021cf8e">More...</a><br /></td></tr>
<tr class="separator:ga2c8a002edae139b24bde39eff021cf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4af34fe82269a8a963c1a6b7850df8dc">rc_vector_sum_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2)</td></tr>
<tr class="memdesc:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector v2 to v1 and leaves the result in v1.  <a href="#ga4af34fe82269a8a963c1a6b7850df8dc">More...</a><br /></td></tr>
<tr class="separator:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga3a7fb920667dee8dd9e00f7a7a2534c4"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga3a7fb920667dee8dd9e00f7a7a2534c4">d</a></td></tr>
<tr class="separator:ga3a7fb920667dee8dd9e00f7a7a2534c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439227feff9d7f55384e8780cfc2eb82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga439227feff9d7f55384e8780cfc2eb82">size</a></td></tr>
<tr class="separator:ga439227feff9d7f55384e8780cfc2eb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga750b5d744c39a06bfb13e6eb010e35d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga750b5d744c39a06bfb13e6eb010e35d0">index</a></td></tr>
<tr class="separator:ga750b5d744c39a06bfb13e6eb010e35d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad06983e7f6e71b233ea7ff3dee1952f2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gad06983e7f6e71b233ea7ff3dee1952f2">initialized</a></td></tr>
<tr class="separator:gad06983e7f6e71b233ea7ff3dee1952f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is a collection of functions for generating and implementing discrete SISO filters for arbitrary transfer functions. </p>
<p>A collection of hardware-accelerated linear algebra functions used heavily by the rest of the rc_math API.</p>
<p>Ring buffer implementation for single-precision floats.</p>
<p>Collection of quaternion manipulation functions.</p>
<p>Collection of polynomial manipulation functions.</p>
<p>general low-level math functions that don't fit elsewhere</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016</dd></dl>
<p>We represent polynomials as a vector of coefficients with the highest power term on the left at vector index 0. The following polynomial manipulation functions are designed to behave like their counterparts in the Numerical Renaissance codebase.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016</dd></dl>
<p>Ring buffers are FIFO (first in first out) buffers of fixed length which efficiently boot out the oldest value when full. They are particularly well suited for storing the last n values in a discrete time filter.</p>
<p>The user creates their own instance of a buffer and passes a pointer to the these ring_buf functions to perform normal operations.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016</dd></dl>
<p>A small <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct contains information about the vector's size and a pointer to where dynamically allocated memory exists that stores the actual data for the vector. Use rc_vector_alloc to dynamically allocate memory for each new vector. Then use rc_vector_free and to free the memory when you are done using it. See the remaining vector, matrix, and linear algebra functions for more details.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab41dce761fc5db225d8cc88f9b131a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab41dce761fc5db225d8cc88f9b131a66">&#9670;&nbsp;</a></span>rc_filter_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__filter__t.html">rc_filter_t</a>  <a class="el" href="structrc__filter__t.html">rc_filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing configuration and state of a SISO filter. </p>
<p>Also points to dynamically allocated memory which make it necessary to use the allocation and free function in this API for proper use. The user can read and modify values directly from ths struct. </p>

</div>
</div>
<a id="gaffc2f47a5af64e67792773720eb9b978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffc2f47a5af64e67792773720eb9b978">&#9670;&nbsp;</a></span>rc_ringbuf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>  <a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing state of a ringbuffer and pointer to dynamically allocated memory. </p>

</div>
</div>
<a id="ga356f39688934d6424182bfb27d60c5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga356f39688934d6424182bfb27d60c5e1">&#9670;&nbsp;</a></span>rc_vector_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__vector__t.html">rc_vector_t</a>  <a class="el" href="structrc__vector__t.html">rc_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents. </p>
<p>Set and read values directly with this code: </p><div class="fragment"><div class="line">vec.d[position]=new_value; <span class="comment">// set value in the vector</span></div><div class="line">value = v.d[pos]; <span class="comment">// get value from vector</span></div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7c47037413178daf5f6ce513a0587cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c47037413178daf5f6ce513a0587cb6">&#9670;&nbsp;</a></span>rc_filter_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> rc_filter_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Critical function for initializing <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> structs. </p>
<p>This is a very important function. If your d_filter_t struct is not a global variable, then its initial contents cannot be guaranteed to be anything in particular. Therefore it could contain problematic contents which could interfere with functions in this library. Therefore, you should always initialize your filters with rc_filter_empty before using with any other function in this library such as rc_filter_alloc. This serves the same purpose as rc_empty_matrix, rc_vector_empty, and rc_ringbuf_empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Empty zero-filled <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </dd></dl>

</div>
</div>
<a id="ga4e1464a0f94a17f406598456f43e1e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1464a0f94a17f406598456f43e1e84">&#9670;&nbsp;</a></span>rc_filter_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients provided in vectors num and den. </p>
<p>The memory in num and den is duplicated so those vectors can be reused or freed after allocating a filter without fear of disturbing the function of the filter. Argument dt is the timestep in seconds at which the user expects to operate the filter. The length of demonimator den must be at least as large as numerator num to avoid describing an improper transfer function. If <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> pointer f points to an existing filter then the old filter's contents are freed safely to avoid memory leaks. We suggest initializing filter f with rc_filter_empty before calling this function if it is not a global variable to ensure it does not accidentally contain invlaid contents such as null pointers. The filter's order is derived from the length of the denominator polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The numerator vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>The denomenator vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Timestep in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga133af9fe414b88fafedbfb8bf93c7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133af9fe414b88fafedbfb8bf93c7d09">&#9670;&nbsp;</a></span>rc_filter_alloc_from_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_alloc_from_arrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>denlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__math.html#ga4e1464a0f94a17f406598456f43e1e84" title="Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients pro...">rc_filter_alloc()</a>, but takes arrays for the numerator and denominator coefficients instead of vectors. </p>
<p>Arrays num and den must have lengths that form a proper or semi-proper transfer function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Timestep in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>pointer to numerator array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numlen</td><td>The numerator length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>pointer to denominator array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denlen</td><td>The denominator length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gad7b1abf89fc93d78bdcbd3b08842c468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b1abf89fc93d78bdcbd3b08842c468">&#9670;&nbsp;</a></span>rc_filter_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated by a filter's buffers and coefficient vectors. Also resets all filter properties back to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac6dff1f36b8e4ef7db264dd2332d3866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6dff1f36b8e4ef7db264dd2332d3866">&#9670;&nbsp;</a></span>rc_filter_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the transfer function and other statistic of a filter to the screen. </p>
<p>Only works on filters up to order 9.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gab6dcce7fda87d140a7a9793546ff3d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6dcce7fda87d140a7a9793546ff3d6e">&#9670;&nbsp;</a></span>rc_filter_march()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_filter_march </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>March a filter forward one step with new input provided as an argument. </p>
<p>If saturation or soft-start are enabled then the output will automatically be bound appropriately. The steps counter is incremented by one and internal ring buffers are updated accordingly. Once a filter is created, this is typically the only function required afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_input</td><td>The new input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new output which could also be accessed with the newest_output field in the filter struct. </dd></dl>

</div>
</div>
<a id="ga4544fbb000ae45030f1cfd0f0aaff311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4544fbb000ae45030f1cfd0f0aaff311">&#9670;&nbsp;</a></span>rc_filter_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all previous inputs and outputs to 0. Also resets the step counter &amp; saturation flag. </p>
<p>This is sufficient to start the filter again as if it were just created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga2df0afb5d7700221d624237e22c12649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df0afb5d7700221d624237e22c12649">&#9670;&nbsp;</a></span>rc_filter_enable_saturation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_enable_saturation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables saturation between bounds min and max. </p>
<p>If saturation is enabled for a specified filter, the filter will automatically bound the output between min and max. You may ignore this function if you wish the filter to run unbounded. Maxc must be greater than min, but they can both be positive or negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>The lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa670c91acf8c6d633938ea51905a0ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa670c91acf8c6d633938ea51905a0ab7">&#9670;&nbsp;</a></span>rc_filter_get_saturation_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_get_saturation_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the filter saturated the last time step. </p>
<p>This information could also be retrieved by looking at the 'sat_flag' value in the filter struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the filter saturated the last time step. Returns 0 otherwise. </dd></dl>

</div>
</div>
<a id="gad1cfc46c70bf2de23b18a22ebb216d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cfc46c70bf2de23b18a22ebb216d16">&#9670;&nbsp;</a></span>rc_filter_enable_soft_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_enable_soft_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables soft start functionality where the output bound is gradually opened linearly from 0 to the normal saturation range. </p>
<p>This occurs over the time specified from argument 'seconds' from when the filter is first created or reset. Saturation must already be enabled for this to work. This assumes that the user does indeed call rc_filter_march at roughly the same time interval as the 'dt' variable in the filter struct which is set at creation time. The soft-start property is maintained through a call to rc_filter_reset so the filter will soft-start again after each reset. This feature should only really be used for feedback controllers to prevent jerky starts. The saturation flag will not be set during this period as the output is usually expected to be bounded and we don't want to falsely trigger alarms or saturation counters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>Time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaf04ac8f24db32d685a28a2281ab143cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf04ac8f24db32d685a28a2281ab143cf">&#9670;&nbsp;</a></span>rc_filter_previous_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_filter_previous_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the input 'steps' back in time. Steps=0 returns most recent input. </p>
<p>'steps' must be between 0 and order inclusively as those are the only steps retained in memory for normal filter operation. To record values further back in time we suggest creating your own <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The steps back in time, steps=0 returns most recent input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the requested previous input. If there is an error, returns -1.0f and prints an error message. </dd></dl>

</div>
</div>
<a id="gaccd76dd4d434632b69ebeef7dffc104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccd76dd4d434632b69ebeef7dffc104d">&#9670;&nbsp;</a></span>rc_filter_previous_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_filter_previous_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output 'steps' back in time. Steps = 0 returns most recent output. </p>
<p>'steps' must be between 0 and order inclusively as those are the only steps retained in memory for normal filter operation. To record values further back in time we suggest creating your own <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The steps back in time, steps=0 returns most recent output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the requested previous output. If there is an error, returns -1.0f and prints an error message. </dd></dl>

</div>
</div>
<a id="gaed432398b3edd76018844b657c18b6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed432398b3edd76018844b657c18b6c9">&#9670;&nbsp;</a></span>rc_filter_prefill_inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_prefill_inputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills all previous inputs to the filter as if they had been equal to 'in'. </p>
<p>Most useful when starting high-pass filters to prevent unwanted jumps in the output when starting with non-zero input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input value to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga9e465ba6c68031669d1832ab5a11ca22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e465ba6c68031669d1832ab5a11ca22">&#9670;&nbsp;</a></span>rc_filter_prefill_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_prefill_outputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills all previous outputs of the filter as if they had been equal to 'out'. </p>
<p>Most useful when starting low-pass filters to prevent unwanted settling time when starting with non-zero input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>output value to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6fed5adaabaa85e248045185f89f4cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fed5adaabaa85e248045185f89f4cf8">&#9670;&nbsp;</a></span>rc_filter_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new filter f3 by multiplying f1*f2. </p>
<p>The contents of f3 are freed safely if necessary and new memory is allocated to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct to be multiplied </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f3</td><td>Pointer to newly created filter struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga8a8bd927ae75b530b5de9c9020986463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8bd927ae75b530b5de9c9020986463">&#9670;&nbsp;</a></span>rc_filter_c2d_tustin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_c2d_tustin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a discrete time filter with similar dynamics to a provided continuous time transfer function using tustin's approximation with prewarping about a frequency of interest 'w' in radians per second. </p>
<p>Any existing memory allocated for f is freed is necessary to prevent memory leaks. Returns 0 on success or -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>continuous time numerator coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>continuous time denominator coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>prewarping frequency in rad/s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga9e152f66ea01c7516f95b63bcf1480d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e152f66ea01c7516f95b63bcf1480d0">&#9670;&nbsp;</a></span>rc_filter_first_order_lowpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_first_order_lowpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a first order low pass filter. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter. dt is in units of seconds and time_constant is the number of seconds it takes to rise to 63.4% of a steady-state input. This can be used alongside rc_first_order_highpass to make a complementary filter pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tc</td><td>time constant: Seconds it takes to rise to 63.4% of a steady-state input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gafda58e96a2784f113d3ad8339216eeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda58e96a2784f113d3ad8339216eeae">&#9670;&nbsp;</a></span>rc_filter_first_order_highpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_first_order_highpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a first order high pass filter. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter. dt is in units of seconds and time_constant is the number of seconds it takes to decay by 63.4% of a steady-state input. This can be used alongside rc_first_order_highpass to make a complementary filter pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tc</td><td>time constant: Seconds it takes to decay by 63.4% of a steady-state input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa7cbcc1ed92e160992862723167e5c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7cbcc1ed92e160992862723167e5c95">&#9670;&nbsp;</a></span>rc_filter_butterworth_lowpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_butterworth_lowpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Butterworth low pass filter of specified order and cutoff frequency. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order (&gt;=1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>Cuttoff freqauency in rad/s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaca1cca3007150600687be7524c378e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1cca3007150600687be7524c378e19">&#9670;&nbsp;</a></span>rc_filter_butterworth_highpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_butterworth_highpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Butterworth high pass filter of specified order and cutoff frequency. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order (&gt;=1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>Cuttoff freqauency in rad/s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6071427fe1e733ec979c1ffdad462068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6071427fe1e733ec979c1ffdad462068">&#9670;&nbsp;</a></span>rc_filter_moving_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_moving_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a FIR moving average filter that averages over specified number of samples. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The samples to average over (&gt;=2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac10997e97d1d8be64fdb82542a5372c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10997e97d1d8be64fdb82542a5372c1">&#9670;&nbsp;</a></span>rc_filter_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_integrator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a first order integrator. </p>
<p>Like most functions here, the dynamics are only accurate if the filter is called with a timestep corresponding to dt. Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga867da96db2d48e580ca236e104e5e22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga867da96db2d48e580ca236e104e5e22b">&#9670;&nbsp;</a></span>rc_filter_double_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_double_integrator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a second order double integrator. </p>
<p>Like most functions here, the dynamics are only accurate if the filter is called with a timestep corresponding to dt. Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gafdbdcb4d5a38d6bbe78e35528d40c3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbdcb4d5a38d6bbe78e35528d40c3f7">&#9670;&nbsp;</a></span>rc_filter_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a discrete-time implementation of a parallel PID controller with high-frequency rolloff. </p>
<p>This is equivalent to the Matlab function: C = pid(Kp,Ki,Kd,Tf,Ts)</p>
<p>We cannot implement a pure differentiator with a discrete transfer function so this filter has high frequency rolloff with time constant Tf. Smaller Tf results in less rolloff, but Tf must be greater than dt/2 for stability. Returns 0 on success or -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kp</td><td>Proportional constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ki</td><td>Integration constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kd</td><td>Derivative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tf</td><td>High Frequency rolloff time constant (seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga760c0174bed236a311471ea303d43a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760c0174bed236a311471ea303d43a0b">&#9670;&nbsp;</a></span>rc_get_random_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_get_random_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random floating point number between -1 and 1. </p>
<p>Uses standard C rand function and bitwise operations which is much faster than doing floating point arithmetic.</p>
<dl class="section return"><dt>Returns</dt><dd>random floating point number between -1 and 1 </dd></dl>

</div>
</div>
<a id="ga10a283b77c5d02020aee8188053d9139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a283b77c5d02020aee8188053d9139">&#9670;&nbsp;</a></span>rc_get_random_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double rc_get_random_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random double-precision floating point number between -1 and 1. </p>
<p>Uses standard C rand function and bitwise operations which is much faster than doing floating point arithmetic.</p>
<dl class="section return"><dt>Returns</dt><dd>random double-precision floating point number between -1 and 1 </dd></dl>

</div>
</div>
<a id="ga2977f271b49fb61945c338cb37d56731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2977f271b49fb61945c338cb37d56731">&#9670;&nbsp;</a></span>rc_saturate_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_saturate_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies val to be bounded between between min and max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">val</td><td>The value to be checked and possibly modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>The lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if saturation occurred, 0 if val was already in bound, and -1 if min was falsely larger than max. </dd></dl>

</div>
</div>
<a id="ga0db783667dde7eb053dd7ac01bf6f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db783667dde7eb053dd7ac01bf6f9d9">&#9670;&nbsp;</a></span>rc_saturate_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_saturate_double </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies val to be bounded between between min and max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">val</td><td>The value to be checked and possibly modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>The lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if saturation occurred, 0 if val was already in bound, and -1 if min was falsely larger than max. </dd></dl>

</div>
</div>
<a id="ga99d2b3a3b9405b3d01c2be85ef2b731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99d2b3a3b9405b3d01c2be85ef2b731b">&#9670;&nbsp;</a></span>rc_poly_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a polynomial in human-readable format in one line. </p>
<p>Like rc_print_vector, but assumes the contents represent a polynomial and prints the coefficients with trailing powers of x for easier reading. This relies on your terminal supporting unicode UTF-8. numer of coefficients and there the length of vector v must be less than or equal to 10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>polynomial coefficients to be printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga0ec56458baca9a38093d74a444513fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ec56458baca9a38093d74a444513fdd">&#9670;&nbsp;</a></span>rc_poly_conv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolutes the polynomials a&amp;b and places the result in vector c. </p>
<p>This finds the coefficients of the polynomials resulting from multiply a*b. The original contents of c are freed and new memory is allocated if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First set of coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second set of coefficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Vector to output resulting coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gae1ebd34a90a744787f2f2becaaeada2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ebd34a90a744787f2f2becaaeada2f">&#9670;&nbsp;</a></span>rc_poly_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a polynomial a to itself n times where n is greater than or equal to 0. </p>
<p>Places the result in vector b, any existing memory allocated for b is freed and its contents are lost. Returns 0 on success and -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Initial coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Power, must be &gt;=0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>resulting coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gabfb6fa5439346ca03f4404ba65f753d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfb6fa5439346ca03f4404ba65f753d4">&#9670;&nbsp;</a></span>rc_poly_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two polynomials a&amp;b with right justification and place the result in c. </p>
<p>Any existing memory allocated for c is freed and its contents are lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="ga7a8ede505de3ba460edfb4c687fed29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8ede505de3ba460edfb4c687fed29f">&#9670;&nbsp;</a></span>rc_poly_add_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_add_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds polynomials a&amp;b with right justification. </p>
<p>The result is placed in vector a and a's original contents are lost. More memory is allocated for a if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>First input and where output is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9">&#9670;&nbsp;</a></span>rc_poly_subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts two polynomials a-b with right justification and places the result in c. </p>
<p>Any existing memory allocated for c is freed and its contents are lost. Returns 0 on success and -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="ga50a9d83172575f86fa60622d57c816e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a9d83172575f86fa60622d57c816e4">&#9670;&nbsp;</a></span>rc_poly_subtract_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_subtract_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts b from a with right justification. </p>
<p>a stays in place and new memory is allocated only if b is longer than a.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>First input and where output is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gabbae3c7a60135300ec4b7765eb956bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbae3c7a60135300ec4b7765eb956bbe">&#9670;&nbsp;</a></span>rc_poly_differentiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_differentiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dth derivative of the polynomial a and places the result in vector b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input polynomial coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>which derivative to take (&gt;=0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa30b88e21671748ce4008e25dc6f200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa30b88e21671748ce4008e25dc6f200d">&#9670;&nbsp;</a></span>rc_poly_divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>rem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides denominator d into numerator n. The remainder is placed into vector rem and the divisor is placed into vector div. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>numerator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>denominator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">div</td><td>The resulting divisor </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rem</td><td>The resulting remainder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa8aa9ad027e326f7953c7820d860179b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8aa9ad027e326f7953c7820d860179b">&#9670;&nbsp;</a></span>rc_poly_butter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_butter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates coefficients for continuous-time Butterworth polynomial of order N and cutoff wc (rad/s) and places them in vector b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of the polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>cutoff frequency in rad/s </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>resulting coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gafef65d4b842f1bb9effcb4a117d64859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafef65d4b842f1bb9effcb4a117d64859">&#9670;&nbsp;</a></span>rc_quaternion_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_quaternion_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of a quaternion vector by finding its 2-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of a vector of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm, or prints an error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga7ae93ebf3650d5ab34e4739b8bbd9960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae93ebf3650d5ab34e4739b8bbd9960">&#9670;&nbsp;</a></span>rc_quaternion_norm_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_quaternion_norm_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of a quaternion vector by finding its 2-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of an array of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm, or prints an error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="gaa4e42cb59e9789b957067dbf27f011dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e42cb59e9789b957067dbf27f011dd">&#9670;&nbsp;</a></span>rc_normalize_quaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_normalize_quaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a quaternion in-place to have length 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quarternion in form of a vector of lenth 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga542d62f500c6a0b29aa6ab0afc9d4115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542d62f500c6a0b29aa6ab0afc9d4115">&#9670;&nbsp;</a></span>rc_normalize_quaternion_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_normalize_quaternion_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a quaternion in-place to have length 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quarternion in form of an array of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga563e33eda488bf7b8676bf6104905754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga563e33eda488bf7b8676bf6104905754">&#9670;&nbsp;</a></span>rc_quaternion_to_tb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_to_tb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>tb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x). </p>
<p>If tb is already allocated and of length 3 then the new values are written in place, otherwise any existing memory is freed and a new vector of length 3 is allocated for tb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of a vector of lenth 4 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tb</td><td>Output tait-bryan angles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga51dde57b0eca9f3b5a6b977ea65cc660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51dde57b0eca9f3b5a6b977ea65cc660">&#9670;&nbsp;</a></span>rc_quaternion_to_tb_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_quaternion_to_tb_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tb</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of an array of lenth 4 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tb</td><td>Output tait-bryan angles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga5aa85c68c560d6ace81e3cf2b02be92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aa85c68c560d6ace81e3cf2b02be92e">&#9670;&nbsp;</a></span>rc_tb_to_quaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_tb_to_quaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>tb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadcaf3f4a38427c88ef3df9ef66bfa7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcaf3f4a38427c88ef3df9ef66bfa7c5">&#9670;&nbsp;</a></span>rc_tb_to_quaternion_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_tb_to_quaternion_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tb</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae6ff0571c5b14a9c9866ccf659ede2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ff0571c5b14a9c9866ccf659ede2be">&#9670;&nbsp;</a></span>rc_quaternion_conjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_conjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga2f6a22394f69065da0db6814ab4cc809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6a22394f69065da0db6814ab4cc809">&#9670;&nbsp;</a></span>rc_quaternion_conjugate_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_conjugate_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga24c75817dfbb514dbc057c675a6831b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24c75817dfbb514dbc057c675a6831b1">&#9670;&nbsp;</a></span>rc_quaternion_conjugate_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_quaternion_conjugate_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga76abb7da3646cb6200ac7743761298d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76abb7da3646cb6200ac7743761298d0">&#9670;&nbsp;</a></span>rc_quaternion_conjugate_array_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_quaternion_conjugate_array_inplace </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga979a8b5919c153ccdd9cf1611bb5da95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979a8b5919c153ccdd9cf1611bb5da95">&#9670;&nbsp;</a></span>rc_quaternion_imaginary_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_imaginary_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga69f6fc81fa687d8341bd78dff1e8357e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69f6fc81fa687d8341bd78dff1e8357e">&#9670;&nbsp;</a></span>rc_quaternion_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4e6282f73d7e338c0e3d008131d49ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e6282f73d7e338c0e3d008131d49ef7">&#9670;&nbsp;</a></span>rc_quaternion_multiply_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_quaternion_multiply_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa3354c12cc243ed0610cf00099f74bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3354c12cc243ed0610cf00099f74bab">&#9670;&nbsp;</a></span>rc_rotate_quaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_rotate_quaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gadd6b10bac88cd15045324b029749b562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd6b10bac88cd15045324b029749b562">&#9670;&nbsp;</a></span>rc_rotate_quaternion_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_rotate_quaternion_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4dcacf759d45c9c92782253338c1269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dcacf759d45c9c92782253338c1269b">&#9670;&nbsp;</a></span>rc_quaternion_rotate_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_rotate_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gace7b5ee210fb16ac4153cb3b223dc18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace7b5ee210fb16ac4153cb3b223dc18e">&#9670;&nbsp;</a></span>rc_quaternion_rotate_vector_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_quaternion_rotate_vector_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbbeb418f6e71f2eefd7dc57c9bfbc8">&#9670;&nbsp;</a></span>rc_quaternion_to_rotation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_to_rotation_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa154c6584a2367b07cc13fea3f9458e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa154c6584a2367b07cc13fea3f9458e9">&#9670;&nbsp;</a></span>rc_ringbuf_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> rc_ringbuf_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct which is completely zero'd out with no memory allocated for it. </p>
<p>This is essential for declaring new ring buffers since structs declared inside of functions are not necessarily zero'd out which can cause the struct to contain problematic contents leading to segfaults. New ring buffers should be initialized with this before calling rc_ringbuf_alloc.</p>
<dl class="section return"><dt>Returns</dt><dd>empty and ready-to-allocate <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> </dd></dl>

</div>
</div>
<a id="ga081c474a7a3e607a73080f5b7d6de94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081c474a7a3e607a73080f5b7d6de94c">&#9670;&nbsp;</a></span>rc_ringbuf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for a ring buffer and initializes an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct. </p>
<p>If buf is already the right size then it is left untouched. Otherwise any existing memory allocated for buf is freed to avoid memory leaks and new memory is allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td>Pointer to user's buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to allocate space for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gacc048f71fcf6c35008c4a42a4c646d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc048f71fcf6c35008c4a42a4c646d79">&#9670;&nbsp;</a></span>rc_ringbuf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for buffer buf. </p>
<p>Also set the initialized flag to 0 so other functions don't try to access unallocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to user's buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa9da5cc641aed10a6212df49f72669c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9da5cc641aed10a6212df49f72669c3">&#9670;&nbsp;</a></span>rc_ringbuf_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values in the buffer to 0.0f and sets the buffer index back to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to user's buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5c20b9aaa891eb1feb74c76e5e1aa3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c20b9aaa891eb1feb74c76e5e1aa3b2">&#9670;&nbsp;</a></span>rc_ringbuf_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a new float into the ring buffer and updates the index accordingly. </p>
<p>If the buffer was full then the oldest value in the buffer is automatically removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td>Pointer to user's buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga28e03c7c74b16d77515e71effae69132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e03c7c74b16d77515e71effae69132">&#9670;&nbsp;</a></span>rc_ringbuf_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_ringbuf_get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the float which is 'position' steps behind the last value added to the buffer. </p>
<p>If 'position' is given as 0 then the most recent value is returned. The position obviously can't be larger than (buffer size - 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td>Pointer to user's buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>steps back in the buffer to fetch the value from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the requested float. Prints an error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="gac3a7ebb9b092f24f94a65eae283f4cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3a7ebb9b092f24f94a65eae283f4cd2">&#9670;&nbsp;</a></span>rc_ringbuf_std_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_ringbuf_std_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of all values in the ring buffer. </p>
<p>Note that if the buffer has not yet been filled completely before calling this, then the starting values of 0.0f in the unfilled portion of the buffer will still be part of the calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to user's buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the standard deviation of all values in the ring buffer. </dd></dl>

</div>
</div>
<a id="ga033739cf97c12aa0d22e2a38cf658aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga033739cf97c12aa0d22e2a38cf658aa7">&#9670;&nbsp;</a></span>rc_vector_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> rc_vector_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0. </p>
<p>This is esssential for initializing vectors when they are declared since local variables declared in a function without global variable scope in C are not guaranteed to be zeroed out which can lead to bad memory pointers and segfaults if not handled carefully. We recommend initializing all vectors with this function before using rc_vector_alloc or any other function.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0. </dd></dl>

</div>
</div>
<a id="ga11722701079a6c31a88c1b2b5535c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11722701079a6c31a88c1b2b5535c034">&#9670;&nbsp;</a></span>rc_vector_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for vector v to have specified length. </p>
<p>If v is initially the right length then nothing is done and the data in v is preserved. If v is uninitialized or of the wrong length then any existing memory is freed and new memory is allocated, helping to prevent accidental memory leaks.</p>
<p>The contents of the new vector is not guaranteed to be anything in particular as it is allocated with malloc. Use rc_vector_zeros or rc_vector_ones if you require known starting values.</p>
<p>Returns 0 if successful, otherwise returns -1. Will only be unsuccessful if length is invalid or there is insufficient memory available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga866d0dd17fd2d052ffe0edb1ebbcf6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">&#9670;&nbsp;</a></span>rc_vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for vector v. </p>
<p>Also sets the length and initialized flag of the <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct to 0 to indicate to other functions that v no longer points to allocated memory and cannot be used until more memory is allocated such as with rc_vector_alloc or rc_vector_zeros. Returns 0 on success. Will only fail and return -1 if it is passed a NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gaaf406d1cf903d34a2fb175d947b7b9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf406d1cf903d34a2fb175d947b7b9fd">&#9670;&nbsp;</a></span>rc_vector_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with zeros. </p>
<p>uses calloc to allocate new memory. Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga93c2070da0f5b606113068dabcf64606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c2070da0f5b606113068dabcf64606">&#9670;&nbsp;</a></span>rc_vector_ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with ones. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga61b0bc1f274f79017342393a2cf4c768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b0bc1f274f79017342393a2cf4c768">&#9670;&nbsp;</a></span>rc_vector_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with random numbers between -1.0 and 1.0. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gab26ea389839dc7cae224a3709316db03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26ea389839dc7cae224a3709316db03">&#9670;&nbsp;</a></span>rc_vector_fibonnaci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_fibonnaci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with Fibonnaci sequence. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga31a8a6926c3eeabe915ea943976a2e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a8a6926c3eeabe915ea943976a2e0e">&#9670;&nbsp;</a></span>rc_vector_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and populates with values from specified array ptr. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this. This is generally used when the user has an existing array of data and wants to use it with other math functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to array to read values from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga5aade05352c44f0eed9835a2e555254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aade05352c44f0eed9835a2e555254f">&#9670;&nbsp;</a></span>rc_vector_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_duplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates the contents of vector a and into a new vector b. </p>
<p>Simply making a copy of an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct is not sufficient as the <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct simply contains a pointer to the memory allocated to contain the contents of the vector. rc_vector_duplicate sets b to be a new <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with a pointer to freshly-allocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Vector to be duplicated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>pointer to new vector to be allocated and written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gafbd986c3f1759de97760c2e65245fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd986c3f1759de97760c2e65245fc45">&#9670;&nbsp;</a></span>rc_vector_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to stdout the contents of vector v in one line. </p>
<p>This is not advisable for extremely long vectors but serves for quickly debugging or printing results. It prints 4 decimal places with padding for a sign. We recommend <a class="el" href="group__math.html#ga6ea0298241c1b0207aea04cd331041d9" title="Prints to stdout the contents of vector v in one line. ">rc_vector_print_sci()</a> for very small or very large numbers where scientific notation would be more appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6ea0298241c1b0207aea04cd331041d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea0298241c1b0207aea04cd331041d9">&#9670;&nbsp;</a></span>rc_vector_print_sci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_print_sci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to stdout the contents of vector v in one line. </p>
<p>Like rc_vector_print but prints with scientific notation. This is not advisable for extremely long vectors but serves for quickly debugging or printing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac2a9764a948a56fae6d5f1897edf8562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a9764a948a56fae6d5f1897edf8562">&#9670;&nbsp;</a></span>rc_vector_times_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_times_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies every entry in vector v by scalar s. </p>
<p>It is not strictly necessary for v to be provided as a pointer since a copy of the struct v would also contain the correct pointer to the original vector's allocated memory. However, in this library we use the convention of passing an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct or rc_matrix_struct as a pointer when its data is to be modified by the function, and as a normal argument when it is only to be read by the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>scalar multiplier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5553a660876a1576c0bd226e49608e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5553a660876a1576c0bd226e49608e68">&#9670;&nbsp;</a></span>rc_vector_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p is any positive real value. </p>
<p>Just like the matlab norm(v,p) function.</p>
<p>Most common norms are the 1 norm which gives the sum of absolute values of the vector and the 2-norm which is the square root of sum of squares. for infinity and -infinity norms see rc_vector_max and rc_vector_min</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Which norm to use. Positive real values only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector norm. Prints error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga3e4b086af44400fa2fa56af2618bfe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4b086af44400fa2fa56af2618bfe81">&#9670;&nbsp;</a></span>rc_vector_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the maximum value in v. </p>
<p>The value contained in the returned index is the equivalent to the infinity norm. If the max value occurs multiple times then the index of the first instance is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the maximum value in v or -1 on error. </dd></dl>

</div>
</div>
<a id="gaf5cf5dee22ee0807725e86463b3cb415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5cf5dee22ee0807725e86463b3cb415">&#9670;&nbsp;</a></span>rc_vector_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the minimum value in v. </p>
<p>The value contained in the returned index is the equivalent to the -infinity norm. If the minimum value occurs multiple times then the index of the first instance is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the minimum value in v or -1 on error. </dd></dl>

</div>
</div>
<a id="ga0cc3db26b59dc0454321820bfd8c9384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cc3db26b59dc0454321820bfd8c9384">&#9670;&nbsp;</a></span>rc_vector_std_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_std_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of the values in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the standard deviation or prints and error message and return -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga5787bffdc4620a44699a71cd496e7187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5787bffdc4620a44699a71cd496e7187">&#9670;&nbsp;</a></span>rc_vector_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mean (average) of all values in vector v or -1.0f on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mean (average) of all values in vector v or -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga9d6baef58e77a3f6f17cd76d3967dcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6baef58e77a3f6f17cd76d3967dcce">&#9670;&nbsp;</a></span>rc_vector_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_projection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector p with the projection of vector v onto e. </p>
<p>p is resized appropriately and any exising memory is freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="gaca02db03974e50fa834e3512415991bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca02db03974e50fa834e3512415991bb">&#9670;&nbsp;</a></span>rc_vector_dot_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_dot_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dot product of two equal-length vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the dot product, or prints and error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga01bee4c05bf391b3fb30b1b9fa8f7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">&#9670;&nbsp;</a></span>rc_vector_cross_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_cross_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cross-product of two vectors, each of length 3. </p>
<p>The result is placed in vector p and and any existing memory used by p is freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>resulting cross product</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="ga2c8a002edae139b24bde39eff021cf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8a002edae139b24bde39eff021cf8e">&#9670;&nbsp;</a></span>rc_vector_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector s with the sum of vectors v1 and v2. </p>
<p>v1 and v2 must be of the same length. Any existing memory allocated for s is freed and lost, new memory is allocated if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>output sum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="ga4af34fe82269a8a963c1a6b7850df8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af34fe82269a8a963c1a6b7850df8dc">&#9670;&nbsp;</a></span>rc_vector_sum_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_sum_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector v2 to v1 and leaves the result in v1. </p>
<p>The original contents of v1 are lost and v2 is left untouched. v1 and v2 must be of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>User's vector struct, holds the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga3a7fb920667dee8dd9e00f7a7a2534c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a7fb920667dee8dd9e00f7a7a2534c4">&#9670;&nbsp;</a></span>d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* d</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ring__buffer_8h_source.html#l00032">32</a> of file <a class="el" href="ring__buffer_8h_source.html">ring_buffer.h</a>.</p>

</div>
</div>
<a id="ga439227feff9d7f55384e8780cfc2eb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga439227feff9d7f55384e8780cfc2eb82">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; pointer to dynamically allocated data </p>

<p class="definition">Definition at line <a class="el" href="ring__buffer_8h_source.html#l00033">33</a> of file <a class="el" href="ring__buffer_8h_source.html">ring_buffer.h</a>.</p>

</div>
</div>
<a id="ga750b5d744c39a06bfb13e6eb010e35d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga750b5d744c39a06bfb13e6eb010e35d0">&#9670;&nbsp;</a></span>index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; number of elements the buffer can hold </p>

<p class="definition">Definition at line <a class="el" href="ring__buffer_8h_source.html#l00034">34</a> of file <a class="el" href="ring__buffer_8h_source.html">ring_buffer.h</a>.</p>

</div>
</div>
<a id="gad06983e7f6e71b233ea7ff3dee1952f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad06983e7f6e71b233ea7ff3dee1952f2">&#9670;&nbsp;</a></span>initialized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int initialized</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; index of the most recently added value </p>

<p class="definition">Definition at line <a class="el" href="ring__buffer_8h_source.html#l00035">35</a> of file <a class="el" href="ring__buffer_8h_source.html">ring_buffer.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
