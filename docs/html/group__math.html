<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rc_mpu: Math</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="strawsondesign_logo_text_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rc_mpu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__math.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Math</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a collection of functions for generating and implementing discrete SISO filters for arbitrary transfer functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__filter__t.html">rc_filter_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing configuration and state of a SISO filter.  <a href="structrc__filter__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its contents.  <a href="structrc__matrix__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing state of a ringbuffer and pointer to dynamically allocated memory.  <a href="structrc__ringbuf__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__vector__t.html">rc_vector_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents.  <a href="structrc__vector__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab41dce761fc5db225d8cc88f9b131a66"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab41dce761fc5db225d8cc88f9b131a66">rc_filter_t</a></td></tr>
<tr class="memdesc:gab41dce761fc5db225d8cc88f9b131a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing configuration and state of a SISO filter.  <a href="#gab41dce761fc5db225d8cc88f9b131a66">More...</a><br /></td></tr>
<tr class="separator:gab41dce761fc5db225d8cc88f9b131a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga080202a036371a8db4916c41c1d57279"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga080202a036371a8db4916c41c1d57279">rc_matrix_t</a></td></tr>
<tr class="memdesc:ga080202a036371a8db4916c41c1d57279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its contents.  <a href="#ga080202a036371a8db4916c41c1d57279">More...</a><br /></td></tr>
<tr class="separator:ga080202a036371a8db4916c41c1d57279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffc2f47a5af64e67792773720eb9b978"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaffc2f47a5af64e67792773720eb9b978">rc_ringbuf_t</a></td></tr>
<tr class="memdesc:gaffc2f47a5af64e67792773720eb9b978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing state of a ringbuffer and pointer to dynamically allocated memory.  <a href="#gaffc2f47a5af64e67792773720eb9b978">More...</a><br /></td></tr>
<tr class="separator:gaffc2f47a5af64e67792773720eb9b978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga356f39688934d6424182bfb27d60c5e1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga356f39688934d6424182bfb27d60c5e1">rc_vector_t</a></td></tr>
<tr class="memdesc:ga356f39688934d6424182bfb27d60c5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents.  <a href="#ga356f39688934d6424182bfb27d60c5e1">More...</a><br /></td></tr>
<tr class="separator:ga356f39688934d6424182bfb27d60c5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7c47037413178daf5f6ce513a0587cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7c47037413178daf5f6ce513a0587cb6">rc_filter_empty</a> ()</td></tr>
<tr class="memdesc:ga7c47037413178daf5f6ce513a0587cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Critical function for initializing <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> structs.  <a href="#ga7c47037413178daf5f6ce513a0587cb6">More...</a><br /></td></tr>
<tr class="separator:ga7c47037413178daf5f6ce513a0587cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1464a0f94a17f406598456f43e1e84"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4e1464a0f94a17f406598456f43e1e84">rc_filter_alloc</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> num, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> den, float dt)</td></tr>
<tr class="memdesc:ga4e1464a0f94a17f406598456f43e1e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients provided in vectors num and den.  <a href="#ga4e1464a0f94a17f406598456f43e1e84">More...</a><br /></td></tr>
<tr class="separator:ga4e1464a0f94a17f406598456f43e1e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga133af9fe414b88fafedbfb8bf93c7d09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga133af9fe414b88fafedbfb8bf93c7d09">rc_filter_alloc_from_arrays</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt, float *num, int numlen, float *den, int denlen)</td></tr>
<tr class="memdesc:ga133af9fe414b88fafedbfb8bf93c7d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like <a class="el" href="group__math.html#ga4e1464a0f94a17f406598456f43e1e84" title="Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients pro...">rc_filter_alloc()</a>, but takes arrays for the numerator and denominator coefficients instead of vectors.  <a href="#ga133af9fe414b88fafedbfb8bf93c7d09">More...</a><br /></td></tr>
<tr class="separator:ga133af9fe414b88fafedbfb8bf93c7d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b1abf89fc93d78bdcbd3b08842c468"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gad7b1abf89fc93d78bdcbd3b08842c468">rc_filter_free</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f)</td></tr>
<tr class="memdesc:gad7b1abf89fc93d78bdcbd3b08842c468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated by a filter's buffers and coefficient vectors. Also resets all filter properties back to 0.  <a href="#gad7b1abf89fc93d78bdcbd3b08842c468">More...</a><br /></td></tr>
<tr class="separator:gad7b1abf89fc93d78bdcbd3b08842c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6dff1f36b8e4ef7db264dd2332d3866"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac6dff1f36b8e4ef7db264dd2332d3866">rc_filter_print</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> f)</td></tr>
<tr class="memdesc:gac6dff1f36b8e4ef7db264dd2332d3866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the transfer function and other statistic of a filter to the screen.  <a href="#gac6dff1f36b8e4ef7db264dd2332d3866">More...</a><br /></td></tr>
<tr class="separator:gac6dff1f36b8e4ef7db264dd2332d3866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6dcce7fda87d140a7a9793546ff3d6e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab6dcce7fda87d140a7a9793546ff3d6e">rc_filter_march</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float new_input)</td></tr>
<tr class="memdesc:gab6dcce7fda87d140a7a9793546ff3d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">March a filter forward one step with new input provided as an argument.  <a href="#gab6dcce7fda87d140a7a9793546ff3d6e">More...</a><br /></td></tr>
<tr class="separator:gab6dcce7fda87d140a7a9793546ff3d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4544fbb000ae45030f1cfd0f0aaff311"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4544fbb000ae45030f1cfd0f0aaff311">rc_filter_reset</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f)</td></tr>
<tr class="memdesc:ga4544fbb000ae45030f1cfd0f0aaff311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all previous inputs and outputs to 0. Also resets the step counter &amp; saturation flag.  <a href="#ga4544fbb000ae45030f1cfd0f0aaff311">More...</a><br /></td></tr>
<tr class="separator:ga4544fbb000ae45030f1cfd0f0aaff311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2df0afb5d7700221d624237e22c12649"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2df0afb5d7700221d624237e22c12649">rc_filter_enable_saturation</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float min, float max)</td></tr>
<tr class="memdesc:ga2df0afb5d7700221d624237e22c12649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables saturation between bounds min and max.  <a href="#ga2df0afb5d7700221d624237e22c12649">More...</a><br /></td></tr>
<tr class="separator:ga2df0afb5d7700221d624237e22c12649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa670c91acf8c6d633938ea51905a0ab7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa670c91acf8c6d633938ea51905a0ab7">rc_filter_get_saturation_flag</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f)</td></tr>
<tr class="memdesc:gaa670c91acf8c6d633938ea51905a0ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the filter saturated the last time step.  <a href="#gaa670c91acf8c6d633938ea51905a0ab7">More...</a><br /></td></tr>
<tr class="separator:gaa670c91acf8c6d633938ea51905a0ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1cfc46c70bf2de23b18a22ebb216d16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gad1cfc46c70bf2de23b18a22ebb216d16">rc_filter_enable_soft_start</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float seconds)</td></tr>
<tr class="memdesc:gad1cfc46c70bf2de23b18a22ebb216d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables soft start functionality where the output bound is gradually opened linearly from 0 to the normal saturation range.  <a href="#gad1cfc46c70bf2de23b18a22ebb216d16">More...</a><br /></td></tr>
<tr class="separator:gad1cfc46c70bf2de23b18a22ebb216d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf04ac8f24db32d685a28a2281ab143cf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf04ac8f24db32d685a28a2281ab143cf">rc_filter_previous_input</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int steps)</td></tr>
<tr class="memdesc:gaf04ac8f24db32d685a28a2281ab143cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input 'steps' back in time. Steps=0 returns most recent input.  <a href="#gaf04ac8f24db32d685a28a2281ab143cf">More...</a><br /></td></tr>
<tr class="separator:gaf04ac8f24db32d685a28a2281ab143cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccd76dd4d434632b69ebeef7dffc104d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaccd76dd4d434632b69ebeef7dffc104d">rc_filter_previous_output</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int steps)</td></tr>
<tr class="memdesc:gaccd76dd4d434632b69ebeef7dffc104d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the output 'steps' back in time. Steps = 0 returns most recent output.  <a href="#gaccd76dd4d434632b69ebeef7dffc104d">More...</a><br /></td></tr>
<tr class="separator:gaccd76dd4d434632b69ebeef7dffc104d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed432398b3edd76018844b657c18b6c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaed432398b3edd76018844b657c18b6c9">rc_filter_prefill_inputs</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float in)</td></tr>
<tr class="memdesc:gaed432398b3edd76018844b657c18b6c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills all previous inputs to the filter as if they had been equal to 'in'.  <a href="#gaed432398b3edd76018844b657c18b6c9">More...</a><br /></td></tr>
<tr class="separator:gaed432398b3edd76018844b657c18b6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e465ba6c68031669d1832ab5a11ca22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9e465ba6c68031669d1832ab5a11ca22">rc_filter_prefill_outputs</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float out)</td></tr>
<tr class="memdesc:ga9e465ba6c68031669d1832ab5a11ca22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills all previous outputs of the filter as if they had been equal to 'out'.  <a href="#ga9e465ba6c68031669d1832ab5a11ca22">More...</a><br /></td></tr>
<tr class="separator:ga9e465ba6c68031669d1832ab5a11ca22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fed5adaabaa85e248045185f89f4cf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6fed5adaabaa85e248045185f89f4cf8">rc_filter_multiply</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> f1, <a class="el" href="structrc__filter__t.html">rc_filter_t</a> f2, <a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f3)</td></tr>
<tr class="memdesc:ga6fed5adaabaa85e248045185f89f4cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new filter f3 by multiplying f1*f2.  <a href="#ga6fed5adaabaa85e248045185f89f4cf8">More...</a><br /></td></tr>
<tr class="separator:ga6fed5adaabaa85e248045185f89f4cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a8bd927ae75b530b5de9c9020986463"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga8a8bd927ae75b530b5de9c9020986463">rc_filter_c2d_tustin</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> num, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> den, float dt, float w)</td></tr>
<tr class="memdesc:ga8a8bd927ae75b530b5de9c9020986463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a discrete time filter with similar dynamics to a provided continuous time transfer function using tustin's approximation with prewarping about a frequency of interest 'w' in radians per second.  <a href="#ga8a8bd927ae75b530b5de9c9020986463">More...</a><br /></td></tr>
<tr class="separator:ga8a8bd927ae75b530b5de9c9020986463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e152f66ea01c7516f95b63bcf1480d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9e152f66ea01c7516f95b63bcf1480d0">rc_filter_first_order_lowpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt, float tc)</td></tr>
<tr class="memdesc:ga9e152f66ea01c7516f95b63bcf1480d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a first order low pass filter.  <a href="#ga9e152f66ea01c7516f95b63bcf1480d0">More...</a><br /></td></tr>
<tr class="separator:ga9e152f66ea01c7516f95b63bcf1480d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafda58e96a2784f113d3ad8339216eeae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafda58e96a2784f113d3ad8339216eeae">rc_filter_first_order_highpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt, float tc)</td></tr>
<tr class="memdesc:gafda58e96a2784f113d3ad8339216eeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a first order high pass filter.  <a href="#gafda58e96a2784f113d3ad8339216eeae">More...</a><br /></td></tr>
<tr class="separator:gafda58e96a2784f113d3ad8339216eeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7cbcc1ed92e160992862723167e5c95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa7cbcc1ed92e160992862723167e5c95">rc_filter_butterworth_lowpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int order, float dt, float wc)</td></tr>
<tr class="memdesc:gaa7cbcc1ed92e160992862723167e5c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Butterworth low pass filter of specified order and cutoff frequency.  <a href="#gaa7cbcc1ed92e160992862723167e5c95">More...</a><br /></td></tr>
<tr class="separator:gaa7cbcc1ed92e160992862723167e5c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca1cca3007150600687be7524c378e19"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaca1cca3007150600687be7524c378e19">rc_filter_butterworth_highpass</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int order, float dt, float wc)</td></tr>
<tr class="memdesc:gaca1cca3007150600687be7524c378e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Butterworth high pass filter of specified order and cutoff frequency.  <a href="#gaca1cca3007150600687be7524c378e19">More...</a><br /></td></tr>
<tr class="separator:gaca1cca3007150600687be7524c378e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6071427fe1e733ec979c1ffdad462068"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6071427fe1e733ec979c1ffdad462068">rc_filter_moving_average</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, int samples, int dt)</td></tr>
<tr class="memdesc:ga6071427fe1e733ec979c1ffdad462068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a FIR moving average filter that averages over specified number of samples.  <a href="#ga6071427fe1e733ec979c1ffdad462068">More...</a><br /></td></tr>
<tr class="separator:ga6071427fe1e733ec979c1ffdad462068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac10997e97d1d8be64fdb82542a5372c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac10997e97d1d8be64fdb82542a5372c1">rc_filter_integrator</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt)</td></tr>
<tr class="memdesc:gac10997e97d1d8be64fdb82542a5372c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a first order integrator.  <a href="#gac10997e97d1d8be64fdb82542a5372c1">More...</a><br /></td></tr>
<tr class="separator:gac10997e97d1d8be64fdb82542a5372c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga867da96db2d48e580ca236e104e5e22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga867da96db2d48e580ca236e104e5e22b">rc_filter_double_integrator</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float dt)</td></tr>
<tr class="memdesc:ga867da96db2d48e580ca236e104e5e22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a second order double integrator.  <a href="#ga867da96db2d48e580ca236e104e5e22b">More...</a><br /></td></tr>
<tr class="separator:ga867da96db2d48e580ca236e104e5e22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdbdcb4d5a38d6bbe78e35528d40c3f7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafdbdcb4d5a38d6bbe78e35528d40c3f7">rc_filter_pid</a> (<a class="el" href="structrc__filter__t.html">rc_filter_t</a> *f, float kp, float ki, float kd, float Tf, float dt)</td></tr>
<tr class="memdesc:gafdbdcb4d5a38d6bbe78e35528d40c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a discrete-time implementation of a parallel PID controller with high-frequency rolloff.  <a href="#gafdbdcb4d5a38d6bbe78e35528d40c3f7">More...</a><br /></td></tr>
<tr class="separator:gafdbdcb4d5a38d6bbe78e35528d40c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga688b3c72b1b7054f102cb4a57c0eaf56"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga688b3c72b1b7054f102cb4a57c0eaf56">rc_algebra_lup_decomp</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *L, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *U, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *P)</td></tr>
<tr class="memdesc:ga688b3c72b1b7054f102cb4a57c0eaf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs LUP decomposition on matrix A with partial pivoting.  <a href="#ga688b3c72b1b7054f102cb4a57c0eaf56">More...</a><br /></td></tr>
<tr class="separator:ga688b3c72b1b7054f102cb4a57c0eaf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e6028ba76c3251d3d6e6c065dfd28a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga09e6028ba76c3251d3d6e6c065dfd28a">rc_algebra_qr_decomp</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *Q, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *R)</td></tr>
<tr class="memdesc:ga09e6028ba76c3251d3d6e6c065dfd28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the QR decomposition of matrix A.  <a href="#ga09e6028ba76c3251d3d6e6c065dfd28a">More...</a><br /></td></tr>
<tr class="separator:ga09e6028ba76c3251d3d6e6c065dfd28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1918b5344deff62db7d7210f2f663f62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga1918b5344deff62db7d7210f2f663f62">rc_algebra_invert_matrix</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *Ainv)</td></tr>
<tr class="memdesc:ga1918b5344deff62db7d7210f2f663f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts matrix A via LUP decomposition method.  <a href="#ga1918b5344deff62db7d7210f2f663f62">More...</a><br /></td></tr>
<tr class="separator:ga1918b5344deff62db7d7210f2f663f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf0af53942a159aafb90da77edeefe7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafaf0af53942a159aafb90da77edeefe7">rc_algebra_invert_matrix_inplace</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A)</td></tr>
<tr class="memdesc:gafaf0af53942a159aafb90da77edeefe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts matrix A in place.  <a href="#gafaf0af53942a159aafb90da77edeefe7">More...</a><br /></td></tr>
<tr class="separator:gafaf0af53942a159aafb90da77edeefe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaca27264e06f3115185bcb8a91d72b4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaaca27264e06f3115185bcb8a91d72b4d">rc_algebra_lin_system_solve</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *x)</td></tr>
<tr class="memdesc:gaaca27264e06f3115185bcb8a91d72b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves Ax=b for given matrix A and vector b.  <a href="#gaaca27264e06f3115185bcb8a91d72b4d">More...</a><br /></td></tr>
<tr class="separator:gaaca27264e06f3115185bcb8a91d72b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac846e2d4565a396e56c7d3ccce84af71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac846e2d4565a396e56c7d3ccce84af71">rc_algebra_set_zero_tolerance</a> (float tol)</td></tr>
<tr class="memdesc:gac846e2d4565a396e56c7d3ccce84af71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the zero tolerance for detecting singular matrices.  <a href="#gac846e2d4565a396e56c7d3ccce84af71">More...</a><br /></td></tr>
<tr class="separator:gac846e2d4565a396e56c7d3ccce84af71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba2bdb386795e79ccead5ac58f1f058"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9ba2bdb386795e79ccead5ac58f1f058">rc_algebra_lin_system_solve_qr</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *x)</td></tr>
<tr class="memdesc:ga9ba2bdb386795e79ccead5ac58f1f058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a least-squares solution to the system Ax=b for non-square A using QR decomposition method.  <a href="#ga9ba2bdb386795e79ccead5ac58f1f058">More...</a><br /></td></tr>
<tr class="separator:ga9ba2bdb386795e79ccead5ac58f1f058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc933b6834e5f7020bf6c265ddb0c3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2cc933b6834e5f7020bf6c265ddb0c3f">rc_algebra_fit_ellipsoid</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> points, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *center, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *lengths)</td></tr>
<tr class="memdesc:ga2cc933b6834e5f7020bf6c265ddb0c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fits an ellipsoid to a set of points in 3D space.  <a href="#ga2cc933b6834e5f7020bf6c265ddb0c3f">More...</a><br /></td></tr>
<tr class="separator:ga2cc933b6834e5f7020bf6c265ddb0c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68c770d18929d0d90203dae703eb1b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga68c770d18929d0d90203dae703eb1b8b">rc_matrix_empty</a> ()</td></tr>
<tr class="memdesc:ga68c770d18929d0d90203dae703eb1b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="structrc__matrix__t.html" title="Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its con...">rc_matrix_t</a> with no allocated memory and the initialized flag set to 0.  <a href="#ga68c770d18929d0d90203dae703eb1b8b">More...</a><br /></td></tr>
<tr class="separator:ga68c770d18929d0d90203dae703eb1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaefaab4215ca5fc77ccc905fb0b1f2ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaaefaab4215ca5fc77ccc905fb0b1f2ab">rc_matrix_alloc</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, int rows, int cols)</td></tr>
<tr class="memdesc:gaaefaab4215ca5fc77ccc905fb0b1f2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for matrix A to have size rows&amp;cols.  <a href="#gaaefaab4215ca5fc77ccc905fb0b1f2ab">More...</a><br /></td></tr>
<tr class="separator:gaaefaab4215ca5fc77ccc905fb0b1f2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e16d72aaad4b8f522f459c2cee2a874"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0e16d72aaad4b8f522f459c2cee2a874">rc_matrix_free</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A)</td></tr>
<tr class="memdesc:ga0e16d72aaad4b8f522f459c2cee2a874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for a matrix A.  <a href="#ga0e16d72aaad4b8f522f459c2cee2a874">More...</a><br /></td></tr>
<tr class="separator:ga0e16d72aaad4b8f522f459c2cee2a874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00058fd197b0d55e6e795116f9fd8a94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga00058fd197b0d55e6e795116f9fd8a94">rc_matrix_zeros</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, int rows, int cols)</td></tr>
<tr class="memdesc:ga00058fd197b0d55e6e795116f9fd8a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes matrix A and allocates memory for a matrix with specified rows &amp; columns. The new memory is pre-filled with zeros using calloc. Any existing memory allocated for A is freed if necessary to avoid memory leaks.  <a href="#ga00058fd197b0d55e6e795116f9fd8a94">More...</a><br /></td></tr>
<tr class="separator:ga00058fd197b0d55e6e795116f9fd8a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b702b772126773969500b3cb1465d00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga3b702b772126773969500b3cb1465d00">rc_matrix_identity</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, int dim)</td></tr>
<tr class="memdesc:ga3b702b772126773969500b3cb1465d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes A to be a square identity matrix with dimensions dim-by-dim.  <a href="#ga3b702b772126773969500b3cb1465d00">More...</a><br /></td></tr>
<tr class="separator:ga3b702b772126773969500b3cb1465d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf040aafb6a95b1303668089d9e30a95a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf040aafb6a95b1303668089d9e30a95a">rc_matrix_random</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, int rows, int cols)</td></tr>
<tr class="memdesc:gaf040aafb6a95b1303668089d9e30a95a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a matrix populated with random numbers between -1 and 1.  <a href="#gaf040aafb6a95b1303668089d9e30a95a">More...</a><br /></td></tr>
<tr class="separator:gaf040aafb6a95b1303668089d9e30a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e6fdd2b113e47901ec765ab8a088dfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga1e6fdd2b113e47901ec765ab8a088dfa">rc_matrix_diagonal</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga1e6fdd2b113e47901ec765ab8a088dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a diagonal matrix with the elements of specified vector v.  <a href="#ga1e6fdd2b113e47901ec765ab8a088dfa">More...</a><br /></td></tr>
<tr class="separator:ga1e6fdd2b113e47901ec765ab8a088dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c723819a991789c9ddf5d2121cc0ebc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga8c723819a991789c9ddf5d2121cc0ebc">rc_matrix_duplicate</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *B)</td></tr>
<tr class="memdesc:ga8c723819a991789c9ddf5d2121cc0ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the contents of matrix A and into matrix B.  <a href="#ga8c723819a991789c9ddf5d2121cc0ebc">More...</a><br /></td></tr>
<tr class="separator:ga8c723819a991789c9ddf5d2121cc0ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a6b08be1c38d7840260125a75f1b06d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5a6b08be1c38d7840260125a75f1b06d">rc_matrix_print</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A)</td></tr>
<tr class="memdesc:ga5a6b08be1c38d7840260125a75f1b06d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of matrix A to stdout in decimal notation with 4 decimal places.  <a href="#ga5a6b08be1c38d7840260125a75f1b06d">More...</a><br /></td></tr>
<tr class="separator:ga5a6b08be1c38d7840260125a75f1b06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf403b7b6e6af997ef732ae0310558e62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf403b7b6e6af997ef732ae0310558e62">rc_matrix_print_sci</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A)</td></tr>
<tr class="memdesc:gaf403b7b6e6af997ef732ae0310558e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the contents of matrix A to stdout in scientific notation.  <a href="#gaf403b7b6e6af997ef732ae0310558e62">More...</a><br /></td></tr>
<tr class="separator:gaf403b7b6e6af997ef732ae0310558e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ea81b6e29d5e56939f9849443778511"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2ea81b6e29d5e56939f9849443778511">rc_matrix_times_scalar</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, float s)</td></tr>
<tr class="memdesc:ga2ea81b6e29d5e56939f9849443778511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies every entry in A by scalar value s.  <a href="#ga2ea81b6e29d5e56939f9849443778511">More...</a><br /></td></tr>
<tr class="separator:ga2ea81b6e29d5e56939f9849443778511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58f7c5e2aa2f0b7383faf53f840ad9e9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga58f7c5e2aa2f0b7383faf53f840ad9e9">rc_matrix_multiply</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> B, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *C)</td></tr>
<tr class="memdesc:ga58f7c5e2aa2f0b7383faf53f840ad9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies A*B=C.  <a href="#ga58f7c5e2aa2f0b7383faf53f840ad9e9">More...</a><br /></td></tr>
<tr class="separator:ga58f7c5e2aa2f0b7383faf53f840ad9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27552eede0fb1b2368f36525b54793ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga27552eede0fb1b2368f36525b54793ad">rc_matrix_left_multiply_inplace</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *B)</td></tr>
<tr class="memdesc:ga27552eede0fb1b2368f36525b54793ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies A*B and puts the result back in the place of B.  <a href="#ga27552eede0fb1b2368f36525b54793ad">More...</a><br /></td></tr>
<tr class="separator:ga27552eede0fb1b2368f36525b54793ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadef5caad52f670b91ea558f1f38edb8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gadef5caad52f670b91ea558f1f38edb8e">rc_matrix_right_multiply_inplace</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> B)</td></tr>
<tr class="memdesc:gadef5caad52f670b91ea558f1f38edb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies A*B and puts the result back in the place of A.  <a href="#gadef5caad52f670b91ea558f1f38edb8e">More...</a><br /></td></tr>
<tr class="separator:gadef5caad52f670b91ea558f1f38edb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1850971139797c1f8fae553e77e5fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4a1850971139797c1f8fae553e77e5fe">rc_matrix_add</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> B, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *C)</td></tr>
<tr class="memdesc:ga4a1850971139797c1f8fae553e77e5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds matrices A+B and places the result in C.  <a href="#ga4a1850971139797c1f8fae553e77e5fe">More...</a><br /></td></tr>
<tr class="separator:ga4a1850971139797c1f8fae553e77e5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6447a3fd6ca7abc752ebc7e5671ba4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5f6447a3fd6ca7abc752ebc7e5671ba4">rc_matrix_add_inplace</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> B)</td></tr>
<tr class="memdesc:ga5f6447a3fd6ca7abc752ebc7e5671ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds matrix A to B and places the result back in A.  <a href="#ga5f6447a3fd6ca7abc752ebc7e5671ba4">More...</a><br /></td></tr>
<tr class="separator:ga5f6447a3fd6ca7abc752ebc7e5671ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab15796534f320083f8315aa5a613b495"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab15796534f320083f8315aa5a613b495">rc_matrix_transpose</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *T)</td></tr>
<tr class="memdesc:gab15796534f320083f8315aa5a613b495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes the contents of A and places the result in T.  <a href="#gab15796534f320083f8315aa5a613b495">More...</a><br /></td></tr>
<tr class="separator:gab15796534f320083f8315aa5a613b495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6a7fd781178a95dea4df4182be453ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab6a7fd781178a95dea4df4182be453ca">rc_matrix_transpose_inplace</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A)</td></tr>
<tr class="memdesc:gab6a7fd781178a95dea4df4182be453ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes matrix A in place.  <a href="#gab6a7fd781178a95dea4df4182be453ca">More...</a><br /></td></tr>
<tr class="separator:gab6a7fd781178a95dea4df4182be453ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f3c2a5dcea5a1dcbbf0f54419d9f490"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4f3c2a5dcea5a1dcbbf0f54419d9f490">rc_matrix_times_col_vec</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga4f3c2a5dcea5a1dcbbf0f54419d9f490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies matrix A times column vector v and places the result in column vector c.  <a href="#ga4f3c2a5dcea5a1dcbbf0f54419d9f490">More...</a><br /></td></tr>
<tr class="separator:ga4f3c2a5dcea5a1dcbbf0f54419d9f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8282c41c5e2cf2338c3584a58c9d0597"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga8282c41c5e2cf2338c3584a58c9d0597">rc_matrix_row_vec_times_matrix</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga8282c41c5e2cf2338c3584a58c9d0597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies row vector v times matrix A and places the result in row vector c.  <a href="#ga8282c41c5e2cf2338c3584a58c9d0597">More...</a><br /></td></tr>
<tr class="separator:ga8282c41c5e2cf2338c3584a58c9d0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac58e4907ae2340ea0a3ea4081542a26e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac58e4907ae2340ea0a3ea4081542a26e">rc_matrix_outer_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *A)</td></tr>
<tr class="memdesc:gac58e4907ae2340ea0a3ea4081542a26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes v1 times v2 where v1 is a column vector and v2 is a row vector.  <a href="#gac58e4907ae2340ea0a3ea4081542a26e">More...</a><br /></td></tr>
<tr class="separator:gac58e4907ae2340ea0a3ea4081542a26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19893df3ab86589168ec60a124cd6f5a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga19893df3ab86589168ec60a124cd6f5a">rc_matrix_determinant</a> (<a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> A)</td></tr>
<tr class="memdesc:ga19893df3ab86589168ec60a124cd6f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of square matrix A.  <a href="#ga19893df3ab86589168ec60a124cd6f5a">More...</a><br /></td></tr>
<tr class="separator:ga19893df3ab86589168ec60a124cd6f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga760c0174bed236a311471ea303d43a0b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga760c0174bed236a311471ea303d43a0b">rc_get_random_float</a> ()</td></tr>
<tr class="memdesc:ga760c0174bed236a311471ea303d43a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random floating point number between -1 and 1.  <a href="#ga760c0174bed236a311471ea303d43a0b">More...</a><br /></td></tr>
<tr class="separator:ga760c0174bed236a311471ea303d43a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a283b77c5d02020aee8188053d9139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga10a283b77c5d02020aee8188053d9139">rc_get_random_double</a> ()</td></tr>
<tr class="memdesc:ga10a283b77c5d02020aee8188053d9139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random double-precision floating point number between -1 and 1.  <a href="#ga10a283b77c5d02020aee8188053d9139">More...</a><br /></td></tr>
<tr class="separator:ga10a283b77c5d02020aee8188053d9139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2977f271b49fb61945c338cb37d56731"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2977f271b49fb61945c338cb37d56731">rc_saturate_float</a> (float *val, float min, float max)</td></tr>
<tr class="memdesc:ga2977f271b49fb61945c338cb37d56731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies val to be bounded between between min and max.  <a href="#ga2977f271b49fb61945c338cb37d56731">More...</a><br /></td></tr>
<tr class="separator:ga2977f271b49fb61945c338cb37d56731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0db783667dde7eb053dd7ac01bf6f9d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0db783667dde7eb053dd7ac01bf6f9d9">rc_saturate_double</a> (double *val, double min, double max)</td></tr>
<tr class="memdesc:ga0db783667dde7eb053dd7ac01bf6f9d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies val to be bounded between between min and max.  <a href="#ga0db783667dde7eb053dd7ac01bf6f9d9">More...</a><br /></td></tr>
<tr class="separator:ga0db783667dde7eb053dd7ac01bf6f9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d2b3a3b9405b3d01c2be85ef2b731b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga99d2b3a3b9405b3d01c2be85ef2b731b">rc_poly_print</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga99d2b3a3b9405b3d01c2be85ef2b731b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints a polynomial in human-readable format in one line.  <a href="#ga99d2b3a3b9405b3d01c2be85ef2b731b">More...</a><br /></td></tr>
<tr class="separator:ga99d2b3a3b9405b3d01c2be85ef2b731b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ec56458baca9a38093d74a444513fdd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0ec56458baca9a38093d74a444513fdd">rc_poly_conv</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga0ec56458baca9a38093d74a444513fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolutes the polynomials a&amp;b and places the result in vector c.  <a href="#ga0ec56458baca9a38093d74a444513fdd">More...</a><br /></td></tr>
<tr class="separator:ga0ec56458baca9a38093d74a444513fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ebd34a90a744787f2f2becaaeada2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae1ebd34a90a744787f2f2becaaeada2f">rc_poly_power</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, int n, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:gae1ebd34a90a744787f2f2becaaeada2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raises a polynomial a to itself n times where n is greater than or equal to 0.  <a href="#gae1ebd34a90a744787f2f2becaaeada2f">More...</a><br /></td></tr>
<tr class="separator:gae1ebd34a90a744787f2f2becaaeada2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfb6fa5439346ca03f4404ba65f753d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gabfb6fa5439346ca03f4404ba65f753d4">rc_poly_add</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:gabfb6fa5439346ca03f4404ba65f753d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add two polynomials a&amp;b with right justification and place the result in c.  <a href="#gabfb6fa5439346ca03f4404ba65f753d4">More...</a><br /></td></tr>
<tr class="separator:gabfb6fa5439346ca03f4404ba65f753d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8ede505de3ba460edfb4c687fed29f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7a8ede505de3ba460edfb4c687fed29f">rc_poly_add_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b)</td></tr>
<tr class="memdesc:ga7a8ede505de3ba460edfb4c687fed29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds polynomials a&amp;b with right justification.  <a href="#ga7a8ede505de3ba460edfb4c687fed29f">More...</a><br /></td></tr>
<tr class="separator:ga7a8ede505de3ba460edfb4c687fed29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9">rc_poly_subtract</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts two polynomials a-b with right justification and places the result in c.  <a href="#ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9">More...</a><br /></td></tr>
<tr class="separator:ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50a9d83172575f86fa60622d57c816e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga50a9d83172575f86fa60622d57c816e4">rc_poly_subtract_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b)</td></tr>
<tr class="memdesc:ga50a9d83172575f86fa60622d57c816e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts b from a with right justification.  <a href="#ga50a9d83172575f86fa60622d57c816e4">More...</a><br /></td></tr>
<tr class="separator:ga50a9d83172575f86fa60622d57c816e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbae3c7a60135300ec4b7765eb956bbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gabbae3c7a60135300ec4b7765eb956bbe">rc_poly_differentiate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, int d, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:gabbae3c7a60135300ec4b7765eb956bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dth derivative of the polynomial a and places the result in vector b.  <a href="#gabbae3c7a60135300ec4b7765eb956bbe">More...</a><br /></td></tr>
<tr class="separator:gabbae3c7a60135300ec4b7765eb956bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa30b88e21671748ce4008e25dc6f200d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa30b88e21671748ce4008e25dc6f200d">rc_poly_divide</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> n, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> d, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *div, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *rem)</td></tr>
<tr class="memdesc:gaa30b88e21671748ce4008e25dc6f200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides denominator d into numerator n. The remainder is placed into vector rem and the divisor is placed into vector div.  <a href="#gaa30b88e21671748ce4008e25dc6f200d">More...</a><br /></td></tr>
<tr class="separator:gaa30b88e21671748ce4008e25dc6f200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aa9ad027e326f7953c7820d860179b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa8aa9ad027e326f7953c7820d860179b">rc_poly_butter</a> (int N, float wc, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:gaa8aa9ad027e326f7953c7820d860179b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates coefficients for continuous-time Butterworth polynomial of order N and cutoff wc (rad/s) and places them in vector b.  <a href="#gaa8aa9ad027e326f7953c7820d860179b">More...</a><br /></td></tr>
<tr class="separator:gaa8aa9ad027e326f7953c7820d860179b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef65d4b842f1bb9effcb4a117d64859"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafef65d4b842f1bb9effcb4a117d64859">rc_quaternion_norm</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q)</td></tr>
<tr class="memdesc:gafef65d4b842f1bb9effcb4a117d64859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a quaternion vector by finding its 2-norm.  <a href="#gafef65d4b842f1bb9effcb4a117d64859">More...</a><br /></td></tr>
<tr class="separator:gafef65d4b842f1bb9effcb4a117d64859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae93ebf3650d5ab34e4739b8bbd9960"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga7ae93ebf3650d5ab34e4739b8bbd9960">rc_quaternion_norm_array</a> (float q[4])</td></tr>
<tr class="memdesc:ga7ae93ebf3650d5ab34e4739b8bbd9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a quaternion vector by finding its 2-norm.  <a href="#ga7ae93ebf3650d5ab34e4739b8bbd9960">More...</a><br /></td></tr>
<tr class="separator:ga7ae93ebf3650d5ab34e4739b8bbd9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e42cb59e9789b957067dbf27f011dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa4e42cb59e9789b957067dbf27f011dd">rc_normalize_quaternion</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *q)</td></tr>
<tr class="memdesc:gaa4e42cb59e9789b957067dbf27f011dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion in-place to have length 1.0.  <a href="#gaa4e42cb59e9789b957067dbf27f011dd">More...</a><br /></td></tr>
<tr class="separator:gaa4e42cb59e9789b957067dbf27f011dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542d62f500c6a0b29aa6ab0afc9d4115"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga542d62f500c6a0b29aa6ab0afc9d4115">rc_normalize_quaternion_array</a> (float q[4])</td></tr>
<tr class="memdesc:ga542d62f500c6a0b29aa6ab0afc9d4115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes a quaternion in-place to have length 1.0.  <a href="#ga542d62f500c6a0b29aa6ab0afc9d4115">More...</a><br /></td></tr>
<tr class="separator:ga542d62f500c6a0b29aa6ab0afc9d4115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga563e33eda488bf7b8676bf6104905754"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga563e33eda488bf7b8676bf6104905754">rc_quaternion_to_tb</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *tb)</td></tr>
<tr class="memdesc:ga563e33eda488bf7b8676bf6104905754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x).  <a href="#ga563e33eda488bf7b8676bf6104905754">More...</a><br /></td></tr>
<tr class="separator:ga563e33eda488bf7b8676bf6104905754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43bb5ba9af2a1f981531443893267871"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga43bb5ba9af2a1f981531443893267871">rc_quaternion_to_tb_array</a> (float q[4], float tb[3])</td></tr>
<tr class="memdesc:ga43bb5ba9af2a1f981531443893267871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x).  <a href="#ga43bb5ba9af2a1f981531443893267871">More...</a><br /></td></tr>
<tr class="separator:ga43bb5ba9af2a1f981531443893267871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54339e7a6a4b46357555def9fefd12be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga54339e7a6a4b46357555def9fefd12be">rc_quaternion_from_tb</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> tb, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *q)</td></tr>
<tr class="memdesc:ga54339e7a6a4b46357555def9fefd12be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates quaternion vector q from tait-bryan angles tb.  <a href="#ga54339e7a6a4b46357555def9fefd12be">More...</a><br /></td></tr>
<tr class="separator:ga54339e7a6a4b46357555def9fefd12be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c7f75500f5f847481d8f3029a2278f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga48c7f75500f5f847481d8f3029a2278f">rc_quaternion_from_tb_array</a> (float tb[3], float q[4])</td></tr>
<tr class="memdesc:ga48c7f75500f5f847481d8f3029a2278f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates quaternion vector q from tait-bryan angles tb.  <a href="#ga48c7f75500f5f847481d8f3029a2278f">More...</a><br /></td></tr>
<tr class="separator:ga48c7f75500f5f847481d8f3029a2278f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6ff0571c5b14a9c9866ccf659ede2be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gae6ff0571c5b14a9c9866ccf659ede2be">rc_quaternion_conjugate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:gae6ff0571c5b14a9c9866ccf659ede2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates conjugate of quaternion q.  <a href="#gae6ff0571c5b14a9c9866ccf659ede2be">More...</a><br /></td></tr>
<tr class="separator:gae6ff0571c5b14a9c9866ccf659ede2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f6a22394f69065da0db6814ab4cc809"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2f6a22394f69065da0db6814ab4cc809">rc_quaternion_conjugate_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *q)</td></tr>
<tr class="memdesc:ga2f6a22394f69065da0db6814ab4cc809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates conjugate of quaternion q and overwrites the old q.  <a href="#ga2f6a22394f69065da0db6814ab4cc809">More...</a><br /></td></tr>
<tr class="separator:ga2f6a22394f69065da0db6814ab4cc809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ae914c1a742685b75276fca93e5c6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf5ae914c1a742685b75276fca93e5c6c">rc_quaternion_conjugate_array</a> (float q[4], float c[4])</td></tr>
<tr class="memdesc:gaf5ae914c1a742685b75276fca93e5c6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates conjugate of quaternion q.  <a href="#gaf5ae914c1a742685b75276fca93e5c6c">More...</a><br /></td></tr>
<tr class="separator:gaf5ae914c1a742685b75276fca93e5c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2e607e631ff8eee463b34ad133ce01"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gabb2e607e631ff8eee463b34ad133ce01">rc_quaternion_conjugate_array_inplace</a> (float q[4])</td></tr>
<tr class="memdesc:gabb2e607e631ff8eee463b34ad133ce01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates conjugate of quaternion q and overwrites the old q.  <a href="#gabb2e607e631ff8eee463b34ad133ce01">More...</a><br /></td></tr>
<tr class="separator:gabb2e607e631ff8eee463b34ad133ce01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga979a8b5919c153ccdd9cf1611bb5da95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga979a8b5919c153ccdd9cf1611bb5da95">rc_quaternion_imaginary_part</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *img)</td></tr>
<tr class="memdesc:ga979a8b5919c153ccdd9cf1611bb5da95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector i with the imaginary components ijk of of quaternion vector q.  <a href="#ga979a8b5919c153ccdd9cf1611bb5da95">More...</a><br /></td></tr>
<tr class="separator:ga979a8b5919c153ccdd9cf1611bb5da95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69f6fc81fa687d8341bd78dff1e8357e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga69f6fc81fa687d8341bd78dff1e8357e">rc_quaternion_multiply</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> b, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *c)</td></tr>
<tr class="memdesc:ga69f6fc81fa687d8341bd78dff1e8357e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the quaternion Hamilton product ab=c.  <a href="#ga69f6fc81fa687d8341bd78dff1e8357e">More...</a><br /></td></tr>
<tr class="separator:ga69f6fc81fa687d8341bd78dff1e8357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4baabcfcd995779e1715186b8348d98"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac4baabcfcd995779e1715186b8348d98">rc_quaternion_multiply_array</a> (float a[4], float b[4], float c[4])</td></tr>
<tr class="memdesc:gac4baabcfcd995779e1715186b8348d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the quaternion Hamilton product ab=c.  <a href="#gac4baabcfcd995779e1715186b8348d98">More...</a><br /></td></tr>
<tr class="separator:gac4baabcfcd995779e1715186b8348d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad0d9273c7a78b4efac1066abe01b46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga1ad0d9273c7a78b4efac1066abe01b46">rc_quaternion_rotate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> q)</td></tr>
<tr class="memdesc:ga1ad0d9273c7a78b4efac1066abe01b46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the quaternion p by quaternion q with the operation p'=qpq*.  <a href="#ga1ad0d9273c7a78b4efac1066abe01b46">More...</a><br /></td></tr>
<tr class="separator:ga1ad0d9273c7a78b4efac1066abe01b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga617b73760e4d298716bb8031e2c50411"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga617b73760e4d298716bb8031e2c50411">rc_quaternion_rotate_array</a> (float p[4], float q[4])</td></tr>
<tr class="memdesc:ga617b73760e4d298716bb8031e2c50411"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the quaternion p by quaternion q with the operation p'=qpq*.  <a href="#ga617b73760e4d298716bb8031e2c50411">More...</a><br /></td></tr>
<tr class="separator:ga617b73760e4d298716bb8031e2c50411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dcacf759d45c9c92782253338c1269b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4dcacf759d45c9c92782253338c1269b">rc_quaternion_rotate_vector</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> q)</td></tr>
<tr class="memdesc:ga4dcacf759d45c9c92782253338c1269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a 3D vector v in-place about the origin by quaternion q by converting v to a quaternion and performing the operation p'=qpq*.  <a href="#ga4dcacf759d45c9c92782253338c1269b">More...</a><br /></td></tr>
<tr class="separator:ga4dcacf759d45c9c92782253338c1269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd08918929fcea5a120ee9c6d7d43d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2bd08918929fcea5a120ee9c6d7d43d6">rc_quaternion_rotate_vector_array</a> (float v[3], float q[4])</td></tr>
<tr class="memdesc:ga2bd08918929fcea5a120ee9c6d7d43d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a 3D vector v in-place about the origin by quaternion q by converting v to a quaternion and performing the operation p'=qpq*.  <a href="#ga2bd08918929fcea5a120ee9c6d7d43d6">More...</a><br /></td></tr>
<tr class="separator:ga2bd08918929fcea5a120ee9c6d7d43d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga1fbbeb418f6e71f2eefd7dc57c9bfbc8">rc_quaternion_to_rotation_matrix</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> q, <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *m)</td></tr>
<tr class="memdesc:ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a normalized quaternion to a 3x3 orthogonal rotation matrix.  <a href="#ga1fbbeb418f6e71f2eefd7dc57c9bfbc8">More...</a><br /></td></tr>
<tr class="separator:ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa154c6584a2367b07cc13fea3f9458e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa154c6584a2367b07cc13fea3f9458e9">rc_ringbuf_empty</a> ()</td></tr>
<tr class="memdesc:gaa154c6584a2367b07cc13fea3f9458e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct which is completely zero'd out with no memory allocated for it.  <a href="#gaa154c6584a2367b07cc13fea3f9458e9">More...</a><br /></td></tr>
<tr class="separator:gaa154c6584a2367b07cc13fea3f9458e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga081c474a7a3e607a73080f5b7d6de94c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga081c474a7a3e607a73080f5b7d6de94c">rc_ringbuf_alloc</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf, int size)</td></tr>
<tr class="memdesc:ga081c474a7a3e607a73080f5b7d6de94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for a ring buffer and initializes an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct.  <a href="#ga081c474a7a3e607a73080f5b7d6de94c">More...</a><br /></td></tr>
<tr class="separator:ga081c474a7a3e607a73080f5b7d6de94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc048f71fcf6c35008c4a42a4c646d79"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gacc048f71fcf6c35008c4a42a4c646d79">rc_ringbuf_free</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf)</td></tr>
<tr class="memdesc:gacc048f71fcf6c35008c4a42a4c646d79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for buffer buf.  <a href="#gacc048f71fcf6c35008c4a42a4c646d79">More...</a><br /></td></tr>
<tr class="separator:gacc048f71fcf6c35008c4a42a4c646d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9da5cc641aed10a6212df49f72669c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaa9da5cc641aed10a6212df49f72669c3">rc_ringbuf_reset</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf)</td></tr>
<tr class="memdesc:gaa9da5cc641aed10a6212df49f72669c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all values in the buffer to 0.0f and sets the buffer index back to 0.  <a href="#gaa9da5cc641aed10a6212df49f72669c3">More...</a><br /></td></tr>
<tr class="separator:gaa9da5cc641aed10a6212df49f72669c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c20b9aaa891eb1feb74c76e5e1aa3b2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5c20b9aaa891eb1feb74c76e5e1aa3b2">rc_ringbuf_insert</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf, float val)</td></tr>
<tr class="memdesc:ga5c20b9aaa891eb1feb74c76e5e1aa3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a new float into the ring buffer and updates the index accordingly.  <a href="#ga5c20b9aaa891eb1feb74c76e5e1aa3b2">More...</a><br /></td></tr>
<tr class="separator:ga5c20b9aaa891eb1feb74c76e5e1aa3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28e03c7c74b16d77515e71effae69132"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga28e03c7c74b16d77515e71effae69132">rc_ringbuf_get_value</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *buf, int position)</td></tr>
<tr class="memdesc:ga28e03c7c74b16d77515e71effae69132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the float which is 'position' steps behind the last value added to the buffer.  <a href="#ga28e03c7c74b16d77515e71effae69132">More...</a><br /></td></tr>
<tr class="separator:ga28e03c7c74b16d77515e71effae69132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3a7ebb9b092f24f94a65eae283f4cd2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac3a7ebb9b092f24f94a65eae283f4cd2">rc_ringbuf_std_dev</a> (<a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> buf)</td></tr>
<tr class="memdesc:gac3a7ebb9b092f24f94a65eae283f4cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of all values in the ring buffer.  <a href="#gac3a7ebb9b092f24f94a65eae283f4cd2">More...</a><br /></td></tr>
<tr class="separator:gac3a7ebb9b092f24f94a65eae283f4cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga033739cf97c12aa0d22e2a38cf658aa7">rc_vector_empty</a> ()</td></tr>
<tr class="memdesc:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0.  <a href="#ga033739cf97c12aa0d22e2a38cf658aa7">More...</a><br /></td></tr>
<tr class="separator:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11722701079a6c31a88c1b2b5535c034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga11722701079a6c31a88c1b2b5535c034">rc_vector_alloc</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga11722701079a6c31a88c1b2b5535c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for vector v to have specified length.  <a href="#ga11722701079a6c31a88c1b2b5535c034">More...</a><br /></td></tr>
<tr class="separator:ga11722701079a6c31a88c1b2b5535c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">rc_vector_free</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v)</td></tr>
<tr class="memdesc:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for vector v.  <a href="#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">More...</a><br /></td></tr>
<tr class="separator:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaaf406d1cf903d34a2fb175d947b7b9fd">rc_vector_zeros</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with zeros.  <a href="#gaaf406d1cf903d34a2fb175d947b7b9fd">More...</a><br /></td></tr>
<tr class="separator:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c2070da0f5b606113068dabcf64606"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga93c2070da0f5b606113068dabcf64606">rc_vector_ones</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga93c2070da0f5b606113068dabcf64606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with ones.  <a href="#ga93c2070da0f5b606113068dabcf64606">More...</a><br /></td></tr>
<tr class="separator:ga93c2070da0f5b606113068dabcf64606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b0bc1f274f79017342393a2cf4c768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga61b0bc1f274f79017342393a2cf4c768">rc_vector_random</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga61b0bc1f274f79017342393a2cf4c768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with random numbers between -1.0 and 1.0.  <a href="#ga61b0bc1f274f79017342393a2cf4c768">More...</a><br /></td></tr>
<tr class="separator:ga61b0bc1f274f79017342393a2cf4c768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26ea389839dc7cae224a3709316db03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab26ea389839dc7cae224a3709316db03">rc_vector_fibonnaci</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:gab26ea389839dc7cae224a3709316db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with Fibonnaci sequence.  <a href="#gab26ea389839dc7cae224a3709316db03">More...</a><br /></td></tr>
<tr class="separator:gab26ea389839dc7cae224a3709316db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga31a8a6926c3eeabe915ea943976a2e0e">rc_vector_from_array</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, float *ptr, int length)</td></tr>
<tr class="memdesc:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and populates with values from specified array ptr.  <a href="#ga31a8a6926c3eeabe915ea943976a2e0e">More...</a><br /></td></tr>
<tr class="separator:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aade05352c44f0eed9835a2e555254f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5aade05352c44f0eed9835a2e555254f">rc_vector_duplicate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:ga5aade05352c44f0eed9835a2e555254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the contents of vector a and into a new vector b.  <a href="#ga5aade05352c44f0eed9835a2e555254f">More...</a><br /></td></tr>
<tr class="separator:ga5aade05352c44f0eed9835a2e555254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd986c3f1759de97760c2e65245fc45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gafbd986c3f1759de97760c2e65245fc45">rc_vector_print</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:gafbd986c3f1759de97760c2e65245fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to stdout the contents of vector v in one line.  <a href="#gafbd986c3f1759de97760c2e65245fc45">More...</a><br /></td></tr>
<tr class="separator:gafbd986c3f1759de97760c2e65245fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea0298241c1b0207aea04cd331041d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6ea0298241c1b0207aea04cd331041d9">rc_vector_print_sci</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga6ea0298241c1b0207aea04cd331041d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to stdout the contents of vector v in one line.  <a href="#ga6ea0298241c1b0207aea04cd331041d9">More...</a><br /></td></tr>
<tr class="separator:ga6ea0298241c1b0207aea04cd331041d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a9764a948a56fae6d5f1897edf8562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gac2a9764a948a56fae6d5f1897edf8562">rc_vector_times_scalar</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, float s)</td></tr>
<tr class="memdesc:gac2a9764a948a56fae6d5f1897edf8562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies every entry in vector v by scalar s.  <a href="#gac2a9764a948a56fae6d5f1897edf8562">More...</a><br /></td></tr>
<tr class="separator:gac2a9764a948a56fae6d5f1897edf8562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5553a660876a1576c0bd226e49608e68"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5553a660876a1576c0bd226e49608e68">rc_vector_norm</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, float p)</td></tr>
<tr class="memdesc:ga5553a660876a1576c0bd226e49608e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p is any positive real value.  <a href="#ga5553a660876a1576c0bd226e49608e68">More...</a><br /></td></tr>
<tr class="separator:ga5553a660876a1576c0bd226e49608e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4b086af44400fa2fa56af2618bfe81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga3e4b086af44400fa2fa56af2618bfe81">rc_vector_max</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga3e4b086af44400fa2fa56af2618bfe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the maximum value in v.  <a href="#ga3e4b086af44400fa2fa56af2618bfe81">More...</a><br /></td></tr>
<tr class="separator:ga3e4b086af44400fa2fa56af2618bfe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5cf5dee22ee0807725e86463b3cb415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaf5cf5dee22ee0807725e86463b3cb415">rc_vector_min</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:gaf5cf5dee22ee0807725e86463b3cb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the minimum value in v.  <a href="#gaf5cf5dee22ee0807725e86463b3cb415">More...</a><br /></td></tr>
<tr class="separator:gaf5cf5dee22ee0807725e86463b3cb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc3db26b59dc0454321820bfd8c9384"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga0cc3db26b59dc0454321820bfd8c9384">rc_vector_std_dev</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga0cc3db26b59dc0454321820bfd8c9384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of the values in a vector.  <a href="#ga0cc3db26b59dc0454321820bfd8c9384">More...</a><br /></td></tr>
<tr class="separator:ga0cc3db26b59dc0454321820bfd8c9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5787bffdc4620a44699a71cd496e7187"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga5787bffdc4620a44699a71cd496e7187">rc_vector_mean</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga5787bffdc4620a44699a71cd496e7187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean (average) of all values in vector v or -1.0f on error.  <a href="#ga5787bffdc4620a44699a71cd496e7187">More...</a><br /></td></tr>
<tr class="separator:ga5787bffdc4620a44699a71cd496e7187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga9d6baef58e77a3f6f17cd76d3967dcce">rc_vector_projection</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> e, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p)</td></tr>
<tr class="memdesc:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector p with the projection of vector v onto e.  <a href="#ga9d6baef58e77a3f6f17cd76d3967dcce">More...</a><br /></td></tr>
<tr class="separator:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca02db03974e50fa834e3512415991bb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gaca02db03974e50fa834e3512415991bb">rc_vector_dot_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2)</td></tr>
<tr class="memdesc:gaca02db03974e50fa834e3512415991bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two equal-length vectors.  <a href="#gaca02db03974e50fa834e3512415991bb">More...</a><br /></td></tr>
<tr class="separator:gaca02db03974e50fa834e3512415991bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">rc_vector_cross_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p)</td></tr>
<tr class="memdesc:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross-product of two vectors, each of length 3.  <a href="#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">More...</a><br /></td></tr>
<tr class="separator:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8a002edae139b24bde39eff021cf8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga2c8a002edae139b24bde39eff021cf8e">rc_vector_sum</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *s)</td></tr>
<tr class="memdesc:ga2c8a002edae139b24bde39eff021cf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector s with the sum of vectors v1 and v2.  <a href="#ga2c8a002edae139b24bde39eff021cf8e">More...</a><br /></td></tr>
<tr class="separator:ga2c8a002edae139b24bde39eff021cf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga4af34fe82269a8a963c1a6b7850df8dc">rc_vector_sum_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2)</td></tr>
<tr class="memdesc:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector v2 to v1 and leaves the result in v1.  <a href="#ga4af34fe82269a8a963c1a6b7850df8dc">More...</a><br /></td></tr>
<tr class="separator:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This is a collection of functions for generating and implementing discrete SISO filters for arbitrary transfer functions. </p>
<p>A collection of hardware-accelerated linear algebra functions used heavily by the rest of the rc_math API.</p>
<p>Ring buffer implementation for single-precision floats.</p>
<p>Collection of quaternion manipulation functions.</p>
<p>Collection of polynomial manipulation functions.</p>
<p>general low-level math functions that don't fit elsewhere</p>
<p>Collection of advanced linear algebra functions.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016</dd></dl>
<p>We represent polynomials as a vector of coefficients with the highest power term on the left at vector index 0. The following polynomial manipulation functions are designed to behave like their counterparts in the Numerical Renaissance codebase.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016</dd></dl>
<p>Ring buffers are FIFO (first in first out) buffers of fixed length which efficiently boot out the oldest value when full. They are particularly well suited for storing the last n values in a discrete time filter.</p>
<p>The user creates their own instance of a buffer and passes a pointer to the these ring_buf functions to perform normal operations.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016</dd></dl>
<p>A small <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct contains information about the vector's size and a pointer to where dynamically allocated memory exists that stores the actual data for the vector. Use rc_vector_alloc to dynamically allocate memory for each new vector. Then use rc_vector_free and to free the memory when you are done using it. See the remaining vector, matrix, and linear algebra functions for more details.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gab41dce761fc5db225d8cc88f9b131a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab41dce761fc5db225d8cc88f9b131a66">&#9670;&nbsp;</a></span>rc_filter_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__filter__t.html">rc_filter_t</a>  <a class="el" href="structrc__filter__t.html">rc_filter_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing configuration and state of a SISO filter. </p>
<p>Also points to dynamically allocated memory which make it necessary to use the allocation and free function in this API for proper use. The user can read and modify values directly from ths struct. </p>

</div>
</div>
<a id="ga080202a036371a8db4916c41c1d57279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga080202a036371a8db4916c41c1d57279">&#9670;&nbsp;</a></span>rc_matrix_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>  <a class="el" href="structrc__matrix__t.html">rc_matrix_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its contents. </p>
<p>Set and read values directly with this code: </p><div class="fragment"><div class="line">matrix.d[row][col]=new_value; <span class="comment">// set value in the matrix</span></div><div class="line">value = matrix.d[row][col]; <span class="comment">// get value from matrix</span></div></div><!-- fragment --> 
</div>
</div>
<a id="gaffc2f47a5af64e67792773720eb9b978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffc2f47a5af64e67792773720eb9b978">&#9670;&nbsp;</a></span>rc_ringbuf_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>  <a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing state of a ringbuffer and pointer to dynamically allocated memory. </p>

</div>
</div>
<a id="ga356f39688934d6424182bfb27d60c5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga356f39688934d6424182bfb27d60c5e1">&#9670;&nbsp;</a></span>rc_vector_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__vector__t.html">rc_vector_t</a>  <a class="el" href="structrc__vector__t.html">rc_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents. </p>
<p>Set and read values directly with this code: </p><div class="fragment"><div class="line">vec.d[position]=new_value; <span class="comment">// set value in the vector</span></div><div class="line">value = v.d[pos]; <span class="comment">// get value from vector</span></div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7c47037413178daf5f6ce513a0587cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c47037413178daf5f6ce513a0587cb6">&#9670;&nbsp;</a></span>rc_filter_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> rc_filter_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Critical function for initializing <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> structs. </p>
<p>This is a very important function. If your d_filter_t struct is not a global variable, then its initial contents cannot be guaranteed to be anything in particular. Therefore it could contain problematic contents which could interfere with functions in this library. Therefore, you should always initialize your filters with rc_filter_empty before using with any other function in this library such as rc_filter_alloc. This serves the same purpose as rc_matrix_empty, rc_vector_empty, and rc_ringbuf_empty.</p>
<dl class="section return"><dt>Returns</dt><dd>Empty zero-filled <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </dd></dl>

</div>
</div>
<a id="ga4e1464a0f94a17f406598456f43e1e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1464a0f94a17f406598456f43e1e84">&#9670;&nbsp;</a></span>rc_filter_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients provided in vectors num and den. </p>
<p>The memory in num and den is duplicated so those vectors can be reused or freed after allocating a filter without fear of disturbing the function of the filter. Argument dt is the timestep in seconds at which the user expects to operate the filter. The length of demonimator den must be at least as large as numerator num to avoid describing an improper transfer function. If <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> pointer f points to an existing filter then the old filter's contents are freed safely to avoid memory leaks. We suggest initializing filter f with rc_filter_empty before calling this function if it is not a global variable to ensure it does not accidentally contain invlaid contents such as null pointers. The filter's order is derived from the length of the denominator polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>The numerator vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>The denomenator vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Timestep in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga133af9fe414b88fafedbfb8bf93c7d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga133af9fe414b88fafedbfb8bf93c7d09">&#9670;&nbsp;</a></span>rc_filter_alloc_from_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_alloc_from_arrays </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>denlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like <a class="el" href="group__math.html#ga4e1464a0f94a17f406598456f43e1e84" title="Allocate memory for a discrete-time filter &amp; populates it with the transfer function coefficients pro...">rc_filter_alloc()</a>, but takes arrays for the numerator and denominator coefficients instead of vectors. </p>
<p>Arrays num and den must have lengths that form a proper or semi-proper transfer function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Timestep in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>pointer to numerator array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numlen</td><td>The numerator length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>pointer to denominator array </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">denlen</td><td>The denominator length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gad7b1abf89fc93d78bdcbd3b08842c468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b1abf89fc93d78bdcbd3b08842c468">&#9670;&nbsp;</a></span>rc_filter_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated by a filter's buffers and coefficient vectors. Also resets all filter properties back to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac6dff1f36b8e4ef7db264dd2332d3866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6dff1f36b8e4ef7db264dd2332d3866">&#9670;&nbsp;</a></span>rc_filter_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the transfer function and other statistic of a filter to the screen. </p>
<p>Only works on filters up to order 9.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gab6dcce7fda87d140a7a9793546ff3d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6dcce7fda87d140a7a9793546ff3d6e">&#9670;&nbsp;</a></span>rc_filter_march()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_filter_march </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>new_input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>March a filter forward one step with new input provided as an argument. </p>
<p>If saturation or soft-start are enabled then the output will automatically be bound appropriately. The steps counter is incremented by one and internal ring buffers are updated accordingly. Once a filter is created, this is typically the only function required afterwards.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_input</td><td>The new input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the new output which could also be accessed with the newest_output field in the filter struct. </dd></dl>

</div>
</div>
<a id="ga4544fbb000ae45030f1cfd0f0aaff311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4544fbb000ae45030f1cfd0f0aaff311">&#9670;&nbsp;</a></span>rc_filter_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all previous inputs and outputs to 0. Also resets the step counter &amp; saturation flag. </p>
<p>This is sufficient to start the filter again as if it were just created.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga2df0afb5d7700221d624237e22c12649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df0afb5d7700221d624237e22c12649">&#9670;&nbsp;</a></span>rc_filter_enable_saturation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_enable_saturation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables saturation between bounds min and max. </p>
<p>If saturation is enabled for a specified filter, the filter will automatically bound the output between min and max. You may ignore this function if you wish the filter to run unbounded. Maxc must be greater than min, but they can both be positive or negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>The lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa670c91acf8c6d633938ea51905a0ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa670c91acf8c6d633938ea51905a0ab7">&#9670;&nbsp;</a></span>rc_filter_get_saturation_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_get_saturation_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the filter saturated the last time step. </p>
<p>This information could also be retrieved by looking at the 'sat_flag' value in the filter struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if the filter saturated the last time step. Returns 0 otherwise. </dd></dl>

</div>
</div>
<a id="gad1cfc46c70bf2de23b18a22ebb216d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1cfc46c70bf2de23b18a22ebb216d16">&#9670;&nbsp;</a></span>rc_filter_enable_soft_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_enable_soft_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>seconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables soft start functionality where the output bound is gradually opened linearly from 0 to the normal saturation range. </p>
<p>This occurs over the time specified from argument 'seconds' from when the filter is first created or reset. Saturation must already be enabled for this to work. This assumes that the user does indeed call rc_filter_march at roughly the same time interval as the 'dt' variable in the filter struct which is set at creation time. The soft-start property is maintained through a call to rc_filter_reset so the filter will soft-start again after each reset. This feature should only really be used for feedback controllers to prevent jerky starts. The saturation flag will not be set during this period as the output is usually expected to be bounded and we don't want to falsely trigger alarms or saturation counters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>Time in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaf04ac8f24db32d685a28a2281ab143cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf04ac8f24db32d685a28a2281ab143cf">&#9670;&nbsp;</a></span>rc_filter_previous_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_filter_previous_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the input 'steps' back in time. Steps=0 returns most recent input. </p>
<p>'steps' must be between 0 and order inclusively as those are the only steps retained in memory for normal filter operation. To record values further back in time we suggest creating your own <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The steps back in time, steps=0 returns most recent input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the requested previous input. If there is an error, returns -1.0f and prints an error message. </dd></dl>

</div>
</div>
<a id="gaccd76dd4d434632b69ebeef7dffc104d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccd76dd4d434632b69ebeef7dffc104d">&#9670;&nbsp;</a></span>rc_filter_previous_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_filter_previous_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the output 'steps' back in time. Steps = 0 returns most recent output. </p>
<p>'steps' must be between 0 and order inclusively as those are the only steps retained in memory for normal filter operation. To record values further back in time we suggest creating your own <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">steps</td><td>The steps back in time, steps=0 returns most recent output.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the requested previous output. If there is an error, returns -1.0f and prints an error message. </dd></dl>

</div>
</div>
<a id="gaed432398b3edd76018844b657c18b6c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed432398b3edd76018844b657c18b6c9">&#9670;&nbsp;</a></span>rc_filter_prefill_inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_prefill_inputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills all previous inputs to the filter as if they had been equal to 'in'. </p>
<p>Most useful when starting high-pass filters to prevent unwanted jumps in the output when starting with non-zero input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">in</td><td>Input value to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga9e465ba6c68031669d1832ab5a11ca22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e465ba6c68031669d1832ab5a11ca22">&#9670;&nbsp;</a></span>rc_filter_prefill_outputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_prefill_outputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills all previous outputs of the filter as if they had been equal to 'out'. </p>
<p>Most useful when starting low-pass filters to prevent unwanted settling time when starting with non-zero input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>output value to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6fed5adaabaa85e248045185f89f4cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fed5adaabaa85e248045185f89f4cf8">&#9670;&nbsp;</a></span>rc_filter_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a>&#160;</td>
          <td class="paramname"><em>f2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new filter f3 by multiplying f1*f2. </p>
<p>The contents of f3 are freed safely if necessary and new memory is allocated to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f1</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct to be multiplied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f2</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct to be multiplied </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">f3</td><td>Pointer to newly created filter struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga8a8bd927ae75b530b5de9c9020986463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a8bd927ae75b530b5de9c9020986463">&#9670;&nbsp;</a></span>rc_filter_c2d_tustin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_c2d_tustin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>den</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a discrete time filter with similar dynamics to a provided continuous time transfer function using tustin's approximation with prewarping about a frequency of interest 'w' in radians per second. </p>
<p>Any existing memory allocated for f is freed is necessary to prevent memory leaks. Returns 0 on success or -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>continuous time numerator coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">den</td><td>continuous time denominator coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">w</td><td>prewarping frequency in rad/s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga9e152f66ea01c7516f95b63bcf1480d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e152f66ea01c7516f95b63bcf1480d0">&#9670;&nbsp;</a></span>rc_filter_first_order_lowpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_first_order_lowpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a first order low pass filter. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter. dt is in units of seconds and time_constant is the number of seconds it takes to rise to 63.4% of a steady-state input. This can be used alongside rc_first_order_highpass to make a complementary filter pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tc</td><td>time constant: Seconds it takes to rise to 63.4% of a steady-state input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gafda58e96a2784f113d3ad8339216eeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafda58e96a2784f113d3ad8339216eeae">&#9670;&nbsp;</a></span>rc_filter_first_order_highpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_first_order_highpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a first order high pass filter. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter. dt is in units of seconds and time_constant is the number of seconds it takes to decay by 63.4% of a steady-state input. This can be used alongside rc_first_order_highpass to make a complementary filter pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tc</td><td>time constant: Seconds it takes to decay by 63.4% of a steady-state input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa7cbcc1ed92e160992862723167e5c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7cbcc1ed92e160992862723167e5c95">&#9670;&nbsp;</a></span>rc_filter_butterworth_lowpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_butterworth_lowpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Butterworth low pass filter of specified order and cutoff frequency. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order (&gt;=1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>Cuttoff freqauency in rad/s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaca1cca3007150600687be7524c378e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca1cca3007150600687be7524c378e19">&#9670;&nbsp;</a></span>rc_filter_butterworth_highpass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_butterworth_highpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Butterworth high pass filter of specified order and cutoff frequency. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>The order (&gt;=1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>Cuttoff freqauency in rad/s</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6071427fe1e733ec979c1ffdad462068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6071427fe1e733ec979c1ffdad462068">&#9670;&nbsp;</a></span>rc_filter_moving_average()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_moving_average </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a FIR moving average filter that averages over specified number of samples. </p>
<p>Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">samples</td><td>The samples to average over (&gt;=2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac10997e97d1d8be64fdb82542a5372c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac10997e97d1d8be64fdb82542a5372c1">&#9670;&nbsp;</a></span>rc_filter_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_integrator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a first order integrator. </p>
<p>Like most functions here, the dynamics are only accurate if the filter is called with a timestep corresponding to dt. Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga867da96db2d48e580ca236e104e5e22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga867da96db2d48e580ca236e104e5e22b">&#9670;&nbsp;</a></span>rc_filter_double_integrator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_double_integrator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a second order double integrator. </p>
<p>Like most functions here, the dynamics are only accurate if the filter is called with a timestep corresponding to dt. Any existing memory allocated for f is freed safely to avoid memory leaks and new memory is allocated for the new filter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gafdbdcb4d5a38d6bbe78e35528d40c3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafdbdcb4d5a38d6bbe78e35528d40c3f7">&#9670;&nbsp;</a></span>rc_filter_pid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_filter_pid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__filter__t.html">rc_filter_t</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ki</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>kd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>Tf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a discrete-time implementation of a parallel PID controller with high-frequency rolloff. </p>
<p>This is equivalent to the Matlab function: C = pid(Kp,Ki,Kd,Tf,Ts)</p>
<p>We cannot implement a pure differentiator with a discrete transfer function so this filter has high frequency rolloff with time constant Tf. Smaller Tf results in less rolloff, but Tf must be greater than dt/2 for stability. Returns 0 on success or -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">f</td><td>Pointer to user's <a class="el" href="structrc__filter__t.html" title="Struct containing configuration and state of a SISO filter. ">rc_filter_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kp</td><td>Proportional constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ki</td><td>Integration constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kd</td><td>Derivative constant </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Tf</td><td>High Frequency rolloff time constant (seconds) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>desired timestep of discrete filter in seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga688b3c72b1b7054f102cb4a57c0eaf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga688b3c72b1b7054f102cb4a57c0eaf56">&#9670;&nbsp;</a></span>rc_algebra_lup_decomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_lup_decomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs LUP decomposition on matrix A with partial pivoting. </p>
<p>Places the result in matrices L,U,&amp;P. Matrix A remains untouched and the original contents of LUP (if any) are freed and LUP are resized appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">L</td><td>lower triangular </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>upper triangular </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>permutation matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga09e6028ba76c3251d3d6e6c065dfd28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e6028ba76c3251d3d6e6c065dfd28a">&#9670;&nbsp;</a></span>rc_algebra_qr_decomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_qr_decomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the QR decomposition of matrix A. </p>
<p>Uses householder reflection method. Matrix A remains untouched and the original contents of Q&amp;R (if any) are freed and resized appropriately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Q</td><td>orthogonal matrix output </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>upper triangular matrix output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga1918b5344deff62db7d7210f2f663f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1918b5344deff62db7d7210f2f663f62">&#9670;&nbsp;</a></span>rc_algebra_invert_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_invert_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>Ainv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts matrix A via LUP decomposition method. </p>
<p>Places the result in matrix Ainv. Any existing memory allocated for Ainv is freed if necessary and its contents are overwritten. Returns -1 if matrix is not invertible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Ainv</td><td>resulting inverted matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gafaf0af53942a159aafb90da77edeefe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaf0af53942a159aafb90da77edeefe7">&#9670;&nbsp;</a></span>rc_algebra_invert_matrix_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_invert_matrix_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts matrix A in place. </p>
<p>The original contents of A are lost. Returns -1 if A is not invertible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix to be inverted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaaca27264e06f3115185bcb8a91d72b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaca27264e06f3115185bcb8a91d72b4d">&#9670;&nbsp;</a></span>rc_algebra_lin_system_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_lin_system_solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves Ax=b for given matrix A and vector b. </p>
<p>Places the result in vector x. existing contents of x are freed and new memory is allocated if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>column vector b </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>solution column vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac846e2d4565a396e56c7d3ccce84af71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac846e2d4565a396e56c7d3ccce84af71">&#9670;&nbsp;</a></span>rc_algebra_set_zero_tolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rc_algebra_set_zero_tolerance </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the zero tolerance for detecting singular matrices. </p>
<p>When inverting matrices or solving a linear system, this library first checks that the determinant of the matrix is non-zero. Due to the rounding errors that come from float-point math, we cannot check if the determinant is exactly zero. Instead, it is checked to be smaller in magnitude than the zero-tolerance.</p>
<p>The default value is 10^-8 but it can be changed here if the user is dealing with unusually small or large floating point values.</p>
<p>This only effects the operation of rc_algebra_invert_matrix, rc_algebra_invert_matrix_inplace, and rc_algebra_lin_system_solve.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>The zero-tolerance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ba2bdb386795e79ccead5ac58f1f058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ba2bdb386795e79ccead5ac58f1f058">&#9670;&nbsp;</a></span>rc_algebra_lin_system_solve_qr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_lin_system_solve_qr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a least-squares solution to the system Ax=b for non-square A using QR decomposition method. </p>
<p>Places the solution in x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>matrix A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>column vector b </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">x</td><td>solution column vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga2cc933b6834e5f7020bf6c265ddb0c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cc933b6834e5f7020bf6c265ddb0c3f">&#9670;&nbsp;</a></span>rc_algebra_fit_ellipsoid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_algebra_fit_ellipsoid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>lengths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fits an ellipsoid to a set of points in 3D space. </p>
<p>The principle axes of the fitted ellipsoid align with the global coordinate system. Therefore there are 6 degrees of freedom defining the ellipsoid: the x,y,z coordinates of the centroid and the lengths from the centroid to the surface in each of the 3 directions.</p>
<p><a class="el" href="structrc__matrix__t.html" title="Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its con...">rc_matrix_t</a> 'points' is a tall matrix with 3 columns and at least 6 rows. Each row must contain the x,y&amp;z components of each individual point to be fit. If only 6 rows are provided, the resulting ellipsoid will be an exact fit. Otherwise the result is a least-squares fit to the over-defined dataset.</p>
<p>The final x,y,z position of the centroid will be placed in vector 'center' and the lengths or radius from the centroid to the surface along each axis will be placed in the vector 'lengths'</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>datapoints to fit </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">center</td><td>center of ellipse </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lengths</td><td>lengths along principle axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga68c770d18929d0d90203dae703eb1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68c770d18929d0d90203dae703eb1b8b">&#9670;&nbsp;</a></span>rc_matrix_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> rc_matrix_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="structrc__matrix__t.html" title="Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its con...">rc_matrix_t</a> with no allocated memory and the initialized flag set to 0. </p>
<p>This is essential for initializing <a class="el" href="structrc__matrix__t.html" title="Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its con...">rc_matrix_t</a> structs when they are declared since local variables declared in a function without global variable scope in C are not guaranteed to be zeroed out which can lead to bad memory pointers and segfaults if not handled carefully. We recommend initializing all matrices with this before using rc_matrix_alloc or any other function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns an empty <a class="el" href="structrc__matrix__t.html" title="Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its con...">rc_matrix_t</a> </dd></dl>

</div>
</div>
<a id="gaaefaab4215ca5fc77ccc905fb0b1f2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaefaab4215ca5fc77ccc905fb0b1f2ab">&#9670;&nbsp;</a></span>rc_matrix_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for matrix A to have size rows&amp;cols. </p>
<p>If A is initially the right size, nothing is done and the data in A is preserved. If A is uninitialized or of the wrong size then any existing memory is freed and new memory is allocated, helping to prevent accidental memory leaks. The contents of the new matrix is not guaranteed to be anything in particular as the memory is allocated with malloc. Will only be unsuccessful if rows&amp;cols are invalid or there is insufficient memory available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Pointer to user's matrix struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>number of columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga0e16d72aaad4b8f522f459c2cee2a874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e16d72aaad4b8f522f459c2cee2a874">&#9670;&nbsp;</a></span>rc_matrix_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for a matrix A. </p>
<p>Also sets the dimensions and initialized flag to 0 to indicate to other functions that A no longer points to allocated memory and cannot be used until more memory is allocated such as with rc_matrix_alloc or rc_matrix_zeros. Will only fail and return -1 if it is passed a NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Pointer to user's matrix struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga00058fd197b0d55e6e795116f9fd8a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00058fd197b0d55e6e795116f9fd8a94">&#9670;&nbsp;</a></span>rc_matrix_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes matrix A and allocates memory for a matrix with specified rows &amp; columns. The new memory is pre-filled with zeros using calloc. Any existing memory allocated for A is freed if necessary to avoid memory leaks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Pointer to user's matrix struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>number of columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga3b702b772126773969500b3cb1465d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b702b772126773969500b3cb1465d00">&#9670;&nbsp;</a></span>rc_matrix_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_identity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes A to be a square identity matrix with dimensions dim-by-dim. </p>
<p>Any existing memory allocated for A is freed if necessary to avoid memory leaks before new memory is allocated for the specified dimension.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Pointer to user's matrix struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>The dimension of one side of square matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="gaf040aafb6a95b1303668089d9e30a95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf040aafb6a95b1303668089d9e30a95a">&#9670;&nbsp;</a></span>rc_matrix_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a matrix populated with random numbers between -1 and 1. </p>
<p>Resizes A to be a matrix with the specified number of rows and columns and populates the new memory with random numbers evenly distributed between -1.0 and 1.0. Any existing memory allocated for A is freed if necessary to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Pointer to user's matrix struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>number of rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cols</td><td>number of columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga1e6fdd2b113e47901ec765ab8a088dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e6fdd2b113e47901ec765ab8a088dfa">&#9670;&nbsp;</a></span>rc_matrix_diagonal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_diagonal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a diagonal matrix with the elements of specified vector v. </p>
<p>Resizes A to be a square matrix with the same number of rows and columns as vector v's length. The diagonal entries of A are then populated with the contents of v and the off-diagonal entries are set to 0. The original contents of A are freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Pointer to user's matrix struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>vector of diagonal entries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga8c723819a991789c9ddf5d2121cc0ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c723819a991789c9ddf5d2121cc0ebc">&#9670;&nbsp;</a></span>rc_matrix_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_duplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates the contents of matrix A and into matrix B. </p>
<p>If B is already the right size then its contents are overwritten. If B is unallocated or is of the wrong size then the memory is freed and new memory is allocated to hold the duplicate of A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to be duplicated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>new matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5a6b08be1c38d7840260125a75f1b06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6b08be1c38d7840260125a75f1b06d">&#9670;&nbsp;</a></span>rc_matrix_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of matrix A to stdout in decimal notation with 4 decimal places. </p>
<p>Not recommended for very large matrices as rows will typically linewrap if the terminal window is not wide enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to print</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="gaf403b7b6e6af997ef732ae0310558e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf403b7b6e6af997ef732ae0310558e62">&#9670;&nbsp;</a></span>rc_matrix_print_sci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_print_sci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the contents of matrix A to stdout in scientific notation. </p>
<p>Prints 4 significant figures. Not recommended for very large matrices as rows will typically linewrap if the terminal window is not wide enough.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Matrix to print</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ga2ea81b6e29d5e56939f9849443778511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea81b6e29d5e56939f9849443778511">&#9670;&nbsp;</a></span>rc_matrix_times_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_times_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies every entry in A by scalar value s. </p>
<p>It is not strictly necessary for A to be provided as a pointer since a copy of the struct A would also contain the correct pointer to the original matrix's allocated memory. However, in this library we use the convention of passing an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct or <a class="el" href="structrc__matrix__t.html" title="Struct containing the state of a matrix and a pointer to dynamically allocated memory to hold its con...">rc_matrix_t</a> struct as a pointer when its data is to be modified by the function, and as a normal argument when it is only to be read by the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Matrix to be modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>scalar to multiply by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga58f7c5e2aa2f0b7383faf53f840ad9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58f7c5e2aa2f0b7383faf53f840ad9e9">&#9670;&nbsp;</a></span>rc_matrix_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies A*B=C. </p>
<p>C is resized and its original contents are freed if necessary to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga27552eede0fb1b2368f36525b54793ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27552eede0fb1b2368f36525b54793ad">&#9670;&nbsp;</a></span>rc_matrix_left_multiply_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_left_multiply_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies A*B and puts the result back in the place of B. </p>
<p>B is resized and its original contents are freed if necessary to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>left matrix in the multiplication </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">B</td><td>right matrix in the multiplication and holder of the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gadef5caad52f670b91ea558f1f38edb8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadef5caad52f670b91ea558f1f38edb8e">&#9670;&nbsp;</a></span>rc_matrix_right_multiply_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_right_multiply_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies A*B and puts the result back in the place of A. </p>
<p>A is resized and its original contents are freed if necessary to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>left matrix in the multiplication and holder of result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>right matrix in the multiplication</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga4a1850971139797c1f8fae553e77e5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a1850971139797c1f8fae553e77e5fe">&#9670;&nbsp;</a></span>rc_matrix_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds matrices A+B and places the result in C. </p>
<p>The original contents of C are safely freed if necessary to avoid memory leaks. Use rc_matrix_add_inplace if you do not need to keep the contents of one of these matrices after addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>First matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5f6447a3fd6ca7abc752ebc7e5671ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f6447a3fd6ca7abc752ebc7e5671ba4">&#9670;&nbsp;</a></span>rc_matrix_add_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_add_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds matrix A to B and places the result back in A. </p>
<p>The original contents of A are lost. Use rc_matrix_add if you wish to keep the contents of both matrix A and B after addition.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>First matrix for addition and holder of the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Second matrix for addition</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gab15796534f320083f8315aa5a613b495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab15796534f320083f8315aa5a613b495">&#9670;&nbsp;</a></span>rc_matrix_transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes the contents of A and places the result in T. </p>
<p>Resizes matrix T to hold the transposed contents of A and leaves A untouched. Original contents of T are safely freed and lost. If the original contents of A are not needed after transposing then use rc_matrix_transpose_inplace instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>resulting transpose</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gab6a7fd781178a95dea4df4182be453ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6a7fd781178a95dea4df4182be453ca">&#9670;&nbsp;</a></span>rc_matrix_transpose_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_transpose_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transposes matrix A in place. </p>
<p>Use as an alternative to rc_matrix_transpose if you no longer have need for the original contents of matrix A.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Pointer to matrix to be transposed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga4f3c2a5dcea5a1dcbbf0f54419d9f490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f3c2a5dcea5a1dcbbf0f54419d9f490">&#9670;&nbsp;</a></span>rc_matrix_times_col_vec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_times_col_vec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies matrix A times column vector v and places the result in column vector c. </p>
<p>Any existing data in c is freed if necessary and c is resized appropriately. Vectors v and c are interpreted as column vectors, but nowhere in their definitions are they actually specified as one or the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga8282c41c5e2cf2338c3584a58c9d0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8282c41c5e2cf2338c3584a58c9d0597">&#9670;&nbsp;</a></span>rc_matrix_row_vec_times_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_row_vec_times_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies row vector v times matrix A and places the result in row vector c. </p>
<p>Any existing data in c is freed if necessary and c is resized appropriately. Vectors v and c are interpreted as row vectors, but nowhere in their definitions are they actually specified as one or the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>input vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac58e4907ae2340ea0a3ea4081542a26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac58e4907ae2340ea0a3ea4081542a26e">&#9670;&nbsp;</a></span>rc_matrix_outer_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_matrix_outer_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes v1 times v2 where v1 is a column vector and v2 is a row vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>Column vector v1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>Row vector v2 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">A</td><td>Output matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga19893df3ab86589168ec60a124cd6f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19893df3ab86589168ec60a124cd6f5a">&#9670;&nbsp;</a></span>rc_matrix_determinant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_matrix_determinant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a>&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the determinant of square matrix A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>input matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the determinant or prints error message and returns -1.0f of error. </dd></dl>

</div>
</div>
<a id="ga760c0174bed236a311471ea303d43a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760c0174bed236a311471ea303d43a0b">&#9670;&nbsp;</a></span>rc_get_random_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_get_random_float </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random floating point number between -1 and 1. </p>
<p>Uses standard C rand function and bitwise operations which is much faster than doing floating point arithmetic.</p>
<dl class="section return"><dt>Returns</dt><dd>random floating point number between -1 and 1 </dd></dl>

</div>
</div>
<a id="ga10a283b77c5d02020aee8188053d9139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10a283b77c5d02020aee8188053d9139">&#9670;&nbsp;</a></span>rc_get_random_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double rc_get_random_double </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random double-precision floating point number between -1 and 1. </p>
<p>Uses standard C rand function and bitwise operations which is much faster than doing floating point arithmetic.</p>
<dl class="section return"><dt>Returns</dt><dd>random double-precision floating point number between -1 and 1 </dd></dl>

</div>
</div>
<a id="ga2977f271b49fb61945c338cb37d56731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2977f271b49fb61945c338cb37d56731">&#9670;&nbsp;</a></span>rc_saturate_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_saturate_float </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies val to be bounded between between min and max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">val</td><td>The value to be checked and possibly modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>The lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if saturation occurred, 0 if val was already in bound, and -1 if min was falsely larger than max. </dd></dl>

</div>
</div>
<a id="ga0db783667dde7eb053dd7ac01bf6f9d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0db783667dde7eb053dd7ac01bf6f9d9">&#9670;&nbsp;</a></span>rc_saturate_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_saturate_double </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies val to be bounded between between min and max. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">val</td><td>The value to be checked and possibly modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min</td><td>The lower bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max</td><td>The upper bound</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 1 if saturation occurred, 0 if val was already in bound, and -1 if min was falsely larger than max. </dd></dl>

</div>
</div>
<a id="ga99d2b3a3b9405b3d01c2be85ef2b731b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99d2b3a3b9405b3d01c2be85ef2b731b">&#9670;&nbsp;</a></span>rc_poly_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints a polynomial in human-readable format in one line. </p>
<p>Like rc_print_vector, but assumes the contents represent a polynomial and prints the coefficients with trailing powers of x for easier reading. This relies on your terminal supporting unicode UTF-8. numer of coefficients and there the length of vector v must be less than or equal to 10.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>polynomial coefficients to be printed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga0ec56458baca9a38093d74a444513fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ec56458baca9a38093d74a444513fdd">&#9670;&nbsp;</a></span>rc_poly_conv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_conv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convolutes the polynomials a&amp;b and places the result in vector c. </p>
<p>This finds the coefficients of the polynomials resulting from multiply a*b. The original contents of c are freed and new memory is allocated if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First set of coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Second set of coefficients </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>Vector to output resulting coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gae1ebd34a90a744787f2f2becaaeada2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ebd34a90a744787f2f2becaaeada2f">&#9670;&nbsp;</a></span>rc_poly_power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_power </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Raises a polynomial a to itself n times where n is greater than or equal to 0. </p>
<p>Places the result in vector b, any existing memory allocated for b is freed and its contents are lost. Returns 0 on success and -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Initial coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Power, must be &gt;=0 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>resulting coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gabfb6fa5439346ca03f4404ba65f753d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfb6fa5439346ca03f4404ba65f753d4">&#9670;&nbsp;</a></span>rc_poly_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add two polynomials a&amp;b with right justification and place the result in c. </p>
<p>Any existing memory allocated for c is freed and its contents are lost.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="ga7a8ede505de3ba460edfb4c687fed29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a8ede505de3ba460edfb4c687fed29f">&#9670;&nbsp;</a></span>rc_poly_add_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_add_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds polynomials a&amp;b with right justification. </p>
<p>The result is placed in vector a and a's original contents are lost. More memory is allocated for a if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>First input and where output is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b4a09e13b28b40bbb2a0f9ddcf9a4f9">&#9670;&nbsp;</a></span>rc_poly_subtract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_subtract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts two polynomials a-b with right justification and places the result in c. </p>
<p>Any existing memory allocated for c is freed and its contents are lost. Returns 0 on success and -1 on failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="ga50a9d83172575f86fa60622d57c816e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50a9d83172575f86fa60622d57c816e4">&#9670;&nbsp;</a></span>rc_poly_subtract_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_subtract_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts b from a with right justification. </p>
<p>a stays in place and new memory is allocated only if b is longer than a.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">a</td><td>First input and where output is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gabbae3c7a60135300ec4b7765eb956bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbae3c7a60135300ec4b7765eb956bbe">&#9670;&nbsp;</a></span>rc_poly_differentiate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_differentiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dth derivative of the polynomial a and places the result in vector b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input polynomial coefficients </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>which derivative to take (&gt;=0) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa30b88e21671748ce4008e25dc6f200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa30b88e21671748ce4008e25dc6f200d">&#9670;&nbsp;</a></span>rc_poly_divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_divide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>div</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>rem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides denominator d into numerator n. The remainder is placed into vector rem and the divisor is placed into vector div. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>numerator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>denominator </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">div</td><td>The resulting divisor </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rem</td><td>The resulting remainder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa8aa9ad027e326f7953c7820d860179b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8aa9ad027e326f7953c7820d860179b">&#9670;&nbsp;</a></span>rc_poly_butter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_poly_butter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>wc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates coefficients for continuous-time Butterworth polynomial of order N and cutoff wc (rad/s) and places them in vector b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Order of the polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wc</td><td>cutoff frequency in rad/s </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>resulting coefficients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success and -1 on failure. </dd></dl>

</div>
</div>
<a id="gafef65d4b842f1bb9effcb4a117d64859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafef65d4b842f1bb9effcb4a117d64859">&#9670;&nbsp;</a></span>rc_quaternion_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_quaternion_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of a quaternion vector by finding its 2-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of a vector of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm, or prints an error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga7ae93ebf3650d5ab34e4739b8bbd9960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ae93ebf3650d5ab34e4739b8bbd9960">&#9670;&nbsp;</a></span>rc_quaternion_norm_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_quaternion_norm_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of a quaternion vector by finding its 2-norm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of an array of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the norm, or prints an error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="gaa4e42cb59e9789b957067dbf27f011dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e42cb59e9789b957067dbf27f011dd">&#9670;&nbsp;</a></span>rc_normalize_quaternion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_normalize_quaternion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a quaternion in-place to have length 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quarternion in form of a vector of lenth 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga542d62f500c6a0b29aa6ab0afc9d4115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542d62f500c6a0b29aa6ab0afc9d4115">&#9670;&nbsp;</a></span>rc_normalize_quaternion_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_normalize_quaternion_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes a quaternion in-place to have length 1.0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q</td><td>The quarternion in form of an array of length 4</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga563e33eda488bf7b8676bf6104905754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga563e33eda488bf7b8676bf6104905754">&#9670;&nbsp;</a></span>rc_quaternion_to_tb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_to_tb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>tb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x). </p>
<p>If tb is already allocated and of length 3 then the new values are written in place, otherwise any existing memory is freed and a new vector of length 3 is allocated for tb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of a vector of lenth 4 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">tb</td><td>Output tait-bryan angles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga43bb5ba9af2a1f981531443893267871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43bb5ba9af2a1f981531443893267871">&#9670;&nbsp;</a></span>rc_quaternion_to_tb_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_to_tb_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tb</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion in form of an array of lenth 4 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tb</td><td>Output tait-bryan angles</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga54339e7a6a4b46357555def9fefd12be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54339e7a6a4b46357555def9fefd12be">&#9670;&nbsp;</a></span>rc_quaternion_from_tb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_from_tb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>tb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates quaternion vector q from tait-bryan angles tb. </p>
<p>If q is already of length 4 then old contents are simply overwritten. Otherwise q'd existing memory is freed and new memory is allocated to aint memory leaks. tb angles are 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tb</td><td>input tait-bryan angles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>output quaternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="ga48c7f75500f5f847481d8f3029a2278f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48c7f75500f5f847481d8f3029a2278f">&#9670;&nbsp;</a></span>rc_quaternion_from_tb_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_from_tb_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tb</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates quaternion vector q from tait-bryan angles tb. </p>
<p>tb angles are 321 Tait Bryan angles in array order XYZ with operation order 321(yaw-Z, pitch-Y, roll-x).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tb</td><td>input tait-bryan angles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">q</td><td>output quaternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure </dd></dl>

</div>
</div>
<a id="gae6ff0571c5b14a9c9866ccf659ede2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6ff0571c5b14a9c9866ccf659ede2be">&#9670;&nbsp;</a></span>rc_quaternion_conjugate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_conjugate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates conjugate of quaternion q. </p>
<p>Populates quaternion vector c with the conjugate of quaternion q where the 3 imaginary parts ijk are multiplied by -1. If c is already of length 4 then the old values are overwritten. Otherwise the old memory in c is freed and new memory is allocated to help prevent memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output conjugate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga2f6a22394f69065da0db6814ab4cc809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f6a22394f69065da0db6814ab4cc809">&#9670;&nbsp;</a></span>rc_quaternion_conjugate_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_conjugate_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates conjugate of quaternion q and overwrites the old q. </p>
<p>Populates quaternion vector q with its conjugate where the 3 imaginary parts ijk are multiplied by -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaf5ae914c1a742685b75276fca93e5c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5ae914c1a742685b75276fca93e5c6c">&#9670;&nbsp;</a></span>rc_quaternion_conjugate_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_conjugate_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates conjugate of quaternion q. </p>
<p>Populates quaternion vector c with the conjugate of quaternion q where the 3 imaginary parts ijk are multiplied by -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output conjugate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gabb2e607e631ff8eee463b34ad133ce01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2e607e631ff8eee463b34ad133ce01">&#9670;&nbsp;</a></span>rc_quaternion_conjugate_array_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_conjugate_array_inplace </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates conjugate of quaternion q and overwrites the old q. </p>
<p>Populates quaternion vector q with its conjugate where the 3 imaginary parts ijk are multiplied by -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga979a8b5919c153ccdd9cf1611bb5da95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga979a8b5919c153ccdd9cf1611bb5da95">&#9670;&nbsp;</a></span>rc_quaternion_imaginary_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_imaginary_part </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>img</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector i with the imaginary components ijk of of quaternion vector q. </p>
<p>If img is already of length 3 then its original contents are overwritten. Otherwise the original allocated memory is freed and new memory is allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarternion </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">img</td><td>imaginary part</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga69f6fc81fa687d8341bd78dff1e8357e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69f6fc81fa687d8341bd78dff1e8357e">&#9670;&nbsp;</a></span>rc_quaternion_multiply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_multiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the quaternion Hamilton product ab=c. </p>
<p>Places the result in vector argument c. If c is already of length 4 then the old values are overwritten. Otherwise the old memory in c is freed and new memory is allocated to help prevent memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac4baabcfcd995779e1715186b8348d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4baabcfcd995779e1715186b8348d98">&#9670;&nbsp;</a></span>rc_quaternion_multiply_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_multiply_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>c</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the quaternion Hamilton product ab=c. </p>
<p>Places the result in vector argument c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>First input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second input </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">c</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga1ad0d9273c7a78b4efac1066abe01b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad0d9273c7a78b4efac1066abe01b46">&#9670;&nbsp;</a></span>rc_quaternion_rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the quaternion p by quaternion q with the operation p'=qpq*. </p>
<p>p is modified in place, q is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>quaternion to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>rotation quarternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga617b73760e4d298716bb8031e2c50411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga617b73760e4d298716bb8031e2c50411">&#9670;&nbsp;</a></span>rc_quaternion_rotate_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_rotate_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotates the quaternion p by quaternion q with the operation p'=qpq*. </p>
<p>p is modified in place, q is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">p</td><td>quaternion to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>rotation quarternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga4dcacf759d45c9c92782253338c1269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dcacf759d45c9c92782253338c1269b">&#9670;&nbsp;</a></span>rc_quaternion_rotate_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_rotate_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate a 3D vector v in-place about the origin by quaternion q by converting v to a quaternion and performing the operation p'=qpq*. </p>
<p>v is modified in place, q is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>vectpr to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>rotation quarternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga2bd08918929fcea5a120ee9c6d7d43d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bd08918929fcea5a120ee9c6d7d43d6">&#9670;&nbsp;</a></span>rc_quaternion_rotate_vector_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_rotate_vector_array </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>v</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>q</em>[4]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rotate a 3D vector v in-place about the origin by quaternion q by converting v to a quaternion and performing the operation p'=qpq*. </p>
<p>v is modified in place, q is unmodified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>vectpr to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>rotation quarternion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga1fbbeb418f6e71f2eefd7dc57c9bfbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fbbeb418f6e71f2eefd7dc57c9bfbc8">&#9670;&nbsp;</a></span>rc_quaternion_to_rotation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_quaternion_to_rotation_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__matrix__t.html">rc_matrix_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a normalized quaternion to a 3x3 orthogonal rotation matrix. </p>
<p>q must be normalized before calling this! The orthogonal matrix corresponds to a rotation by the unit quaternion q when post-multiplied with a column vector as such: v_rotated=mv.</p>
<p>If m is already 3x3 then its contents are overwritten, otherwise its existing memory is freed and new memory is allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quarter </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">m</td><td>output 3x3 rotation matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa154c6584a2367b07cc13fea3f9458e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa154c6584a2367b07cc13fea3f9458e9">&#9670;&nbsp;</a></span>rc_ringbuf_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> rc_ringbuf_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct which is completely zero'd out with no memory allocated for it. </p>
<p>This is essential for declaring new ring buffers since structs declared inside of functions are not necessarily zero'd out which can cause the struct to contain problematic contents leading to segfaults. New ring buffers should be initialized with this before calling rc_ringbuf_alloc.</p>
<dl class="section return"><dt>Returns</dt><dd>empty and ready-to-allocate <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> </dd></dl>

</div>
</div>
<a id="ga081c474a7a3e607a73080f5b7d6de94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga081c474a7a3e607a73080f5b7d6de94c">&#9670;&nbsp;</a></span>rc_ringbuf_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for a ring buffer and initializes an <a class="el" href="structrc__ringbuf__t.html" title="Struct containing state of a ringbuffer and pointer to dynamically allocated memory. ">rc_ringbuf_t</a> struct. </p>
<p>If buf is already the right size then it is left untouched. Otherwise any existing memory allocated for buf is freed to avoid memory leaks and new memory is allocated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td>Pointer to user's buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Number of elements to allocate space for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gacc048f71fcf6c35008c4a42a4c646d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc048f71fcf6c35008c4a42a4c646d79">&#9670;&nbsp;</a></span>rc_ringbuf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for buffer buf. </p>
<p>Also set the initialized flag to 0 so other functions don't try to access unallocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to user's buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gaa9da5cc641aed10a6212df49f72669c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9da5cc641aed10a6212df49f72669c3">&#9670;&nbsp;</a></span>rc_ringbuf_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all values in the buffer to 0.0f and sets the buffer index back to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Pointer to user's buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5c20b9aaa891eb1feb74c76e5e1aa3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c20b9aaa891eb1feb74c76e5e1aa3b2">&#9670;&nbsp;</a></span>rc_ringbuf_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_ringbuf_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts a new float into the ring buffer and updates the index accordingly. </p>
<p>If the buffer was full then the oldest value in the buffer is automatically removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td>Pointer to user's buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to be inserted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga28e03c7c74b16d77515e71effae69132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28e03c7c74b16d77515e71effae69132">&#9670;&nbsp;</a></span>rc_ringbuf_get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_ringbuf_get_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fetches the float which is 'position' steps behind the last value added to the buffer. </p>
<p>If 'position' is given as 0 then the most recent value is returned. The position obviously can't be larger than (buffer size - 1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">buf</td><td>Pointer to user's buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">position</td><td>steps back in the buffer to fetch the value from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the requested float. Prints an error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="gac3a7ebb9b092f24f94a65eae283f4cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3a7ebb9b092f24f94a65eae283f4cd2">&#9670;&nbsp;</a></span>rc_ringbuf_std_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_ringbuf_std_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__ringbuf__t.html">rc_ringbuf_t</a>&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of all values in the ring buffer. </p>
<p>Note that if the buffer has not yet been filled completely before calling this, then the starting values of 0.0f in the unfilled portion of the buffer will still be part of the calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to user's buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the standard deviation of all values in the ring buffer. </dd></dl>

</div>
</div>
<a id="ga033739cf97c12aa0d22e2a38cf658aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga033739cf97c12aa0d22e2a38cf658aa7">&#9670;&nbsp;</a></span>rc_vector_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> rc_vector_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0. </p>
<p>This is esssential for initializing vectors when they are declared since local variables declared in a function without global variable scope in C are not guaranteed to be zeroed out which can lead to bad memory pointers and segfaults if not handled carefully. We recommend initializing all vectors with this function before using rc_vector_alloc or any other function.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0. </dd></dl>

</div>
</div>
<a id="ga11722701079a6c31a88c1b2b5535c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11722701079a6c31a88c1b2b5535c034">&#9670;&nbsp;</a></span>rc_vector_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for vector v to have specified length. </p>
<p>If v is initially the right length then nothing is done and the data in v is preserved. If v is uninitialized or of the wrong length then any existing memory is freed and new memory is allocated, helping to prevent accidental memory leaks.</p>
<p>The contents of the new vector is not guaranteed to be anything in particular as it is allocated with malloc. Use rc_vector_zeros or rc_vector_ones if you require known starting values.</p>
<p>Returns 0 if successful, otherwise returns -1. Will only be unsuccessful if length is invalid or there is insufficient memory available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga866d0dd17fd2d052ffe0edb1ebbcf6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">&#9670;&nbsp;</a></span>rc_vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for vector v. </p>
<p>Also sets the length and initialized flag of the <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct to 0 to indicate to other functions that v no longer points to allocated memory and cannot be used until more memory is allocated such as with rc_vector_alloc or rc_vector_zeros. Returns 0 on success. Will only fail and return -1 if it is passed a NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gaaf406d1cf903d34a2fb175d947b7b9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf406d1cf903d34a2fb175d947b7b9fd">&#9670;&nbsp;</a></span>rc_vector_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with zeros. </p>
<p>uses calloc to allocate new memory. Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga93c2070da0f5b606113068dabcf64606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c2070da0f5b606113068dabcf64606">&#9670;&nbsp;</a></span>rc_vector_ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with ones. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga61b0bc1f274f79017342393a2cf4c768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b0bc1f274f79017342393a2cf4c768">&#9670;&nbsp;</a></span>rc_vector_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with random numbers between -1.0 and 1.0. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gab26ea389839dc7cae224a3709316db03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26ea389839dc7cae224a3709316db03">&#9670;&nbsp;</a></span>rc_vector_fibonnaci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_fibonnaci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with Fibonnaci sequence. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga31a8a6926c3eeabe915ea943976a2e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a8a6926c3eeabe915ea943976a2e0e">&#9670;&nbsp;</a></span>rc_vector_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and populates with values from specified array ptr. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this. This is generally used when the user has an existing array of data and wants to use it with other math functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to array to read values from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga5aade05352c44f0eed9835a2e555254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aade05352c44f0eed9835a2e555254f">&#9670;&nbsp;</a></span>rc_vector_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_duplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates the contents of vector a and into a new vector b. </p>
<p>Simply making a copy of an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct is not sufficient as the <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct simply contains a pointer to the memory allocated to contain the contents of the vector. rc_vector_duplicate sets b to be a new <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with a pointer to freshly-allocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Vector to be duplicated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>pointer to new vector to be allocated and written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gafbd986c3f1759de97760c2e65245fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd986c3f1759de97760c2e65245fc45">&#9670;&nbsp;</a></span>rc_vector_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to stdout the contents of vector v in one line. </p>
<p>This is not advisable for extremely long vectors but serves for quickly debugging or printing results. It prints 4 decimal places with padding for a sign. We recommend <a class="el" href="group__math.html#ga6ea0298241c1b0207aea04cd331041d9" title="Prints to stdout the contents of vector v in one line. ">rc_vector_print_sci()</a> for very small or very large numbers where scientific notation would be more appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6ea0298241c1b0207aea04cd331041d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea0298241c1b0207aea04cd331041d9">&#9670;&nbsp;</a></span>rc_vector_print_sci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_print_sci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to stdout the contents of vector v in one line. </p>
<p>Like rc_vector_print but prints with scientific notation. This is not advisable for extremely long vectors but serves for quickly debugging or printing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac2a9764a948a56fae6d5f1897edf8562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a9764a948a56fae6d5f1897edf8562">&#9670;&nbsp;</a></span>rc_vector_times_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_times_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies every entry in vector v by scalar s. </p>
<p>It is not strictly necessary for v to be provided as a pointer since a copy of the struct v would also contain the correct pointer to the original vector's allocated memory. However, in this library we use the convention of passing an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct or rc_matrix_struct as a pointer when its data is to be modified by the function, and as a normal argument when it is only to be read by the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>scalar multiplier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5553a660876a1576c0bd226e49608e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5553a660876a1576c0bd226e49608e68">&#9670;&nbsp;</a></span>rc_vector_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p is any positive real value. </p>
<p>Just like the matlab norm(v,p) function.</p>
<p>Most common norms are the 1 norm which gives the sum of absolute values of the vector and the 2-norm which is the square root of sum of squares. for infinity and -infinity norms see rc_vector_max and rc_vector_min</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Which norm to use. Positive real values only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector norm. Prints error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga3e4b086af44400fa2fa56af2618bfe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4b086af44400fa2fa56af2618bfe81">&#9670;&nbsp;</a></span>rc_vector_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the maximum value in v. </p>
<p>The value contained in the returned index is the equivalent to the infinity norm. If the max value occurs multiple times then the index of the first instance is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the maximum value in v or -1 on error. </dd></dl>

</div>
</div>
<a id="gaf5cf5dee22ee0807725e86463b3cb415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5cf5dee22ee0807725e86463b3cb415">&#9670;&nbsp;</a></span>rc_vector_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the minimum value in v. </p>
<p>The value contained in the returned index is the equivalent to the -infinity norm. If the minimum value occurs multiple times then the index of the first instance is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the minimum value in v or -1 on error. </dd></dl>

</div>
</div>
<a id="ga0cc3db26b59dc0454321820bfd8c9384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cc3db26b59dc0454321820bfd8c9384">&#9670;&nbsp;</a></span>rc_vector_std_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_std_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of the values in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the standard deviation or prints and error message and return -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga5787bffdc4620a44699a71cd496e7187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5787bffdc4620a44699a71cd496e7187">&#9670;&nbsp;</a></span>rc_vector_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mean (average) of all values in vector v or -1.0f on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mean (average) of all values in vector v or -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga9d6baef58e77a3f6f17cd76d3967dcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6baef58e77a3f6f17cd76d3967dcce">&#9670;&nbsp;</a></span>rc_vector_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_projection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector p with the projection of vector v onto e. </p>
<p>p is resized appropriately and any exising memory is freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="gaca02db03974e50fa834e3512415991bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca02db03974e50fa834e3512415991bb">&#9670;&nbsp;</a></span>rc_vector_dot_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_dot_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dot product of two equal-length vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the dot product, or prints and error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga01bee4c05bf391b3fb30b1b9fa8f7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">&#9670;&nbsp;</a></span>rc_vector_cross_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_cross_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cross-product of two vectors, each of length 3. </p>
<p>The result is placed in vector p and and any existing memory used by p is freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>resulting cross product</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="ga2c8a002edae139b24bde39eff021cf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8a002edae139b24bde39eff021cf8e">&#9670;&nbsp;</a></span>rc_vector_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector s with the sum of vectors v1 and v2. </p>
<p>v1 and v2 must be of the same length. Any existing memory allocated for s is freed and lost, new memory is allocated if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>output sum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="ga4af34fe82269a8a963c1a6b7850df8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af34fe82269a8a963c1a6b7850df8dc">&#9670;&nbsp;</a></span>rc_vector_sum_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_sum_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector v2 to v1 and leaves the result in v1. </p>
<p>The original contents of v1 are lost and v2 is left untouched. v1 and v2 must be of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>User's vector struct, holds the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
