<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rc_mpu: Vector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="strawsondesign_logo_text_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">rc_mpu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Vector<div class="ingroups"><a class="el" href="group__math.html">Math</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>functions for vector manipulation  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>functions for vector manipulation </p>
<p>A small <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct contains information about the vector's size and a pointer to where dynamically allocated memory exists that stores the actual data for the vector. Use rc_vector_alloc to dynamically allocate memory for each new vector. Then use rc_vector_free and to free the memory when you are done using it. See the remaining vector, matrix, and linear algebra functions for more details.</p>
<dl class="section author"><dt>Author</dt><dd>James Strawson </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2016 </dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrc__vector__t.html">rc_vector_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents.  <a href="structrc__vector__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga356f39688934d6424182bfb27d60c5e1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga356f39688934d6424182bfb27d60c5e1">rc_vector_t</a></td></tr>
<tr class="memdesc:ga356f39688934d6424182bfb27d60c5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents.  <a href="#ga356f39688934d6424182bfb27d60c5e1">More...</a><br /></td></tr>
<tr class="separator:ga356f39688934d6424182bfb27d60c5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga033739cf97c12aa0d22e2a38cf658aa7">rc_vector_empty</a> ()</td></tr>
<tr class="memdesc:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0.  <a href="#ga033739cf97c12aa0d22e2a38cf658aa7">More...</a><br /></td></tr>
<tr class="separator:ga033739cf97c12aa0d22e2a38cf658aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11722701079a6c31a88c1b2b5535c034"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga11722701079a6c31a88c1b2b5535c034">rc_vector_alloc</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga11722701079a6c31a88c1b2b5535c034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for vector v to have specified length.  <a href="#ga11722701079a6c31a88c1b2b5535c034">More...</a><br /></td></tr>
<tr class="separator:ga11722701079a6c31a88c1b2b5535c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">rc_vector_free</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v)</td></tr>
<tr class="memdesc:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for vector v.  <a href="#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">More...</a><br /></td></tr>
<tr class="separator:ga866d0dd17fd2d052ffe0edb1ebbcf6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#gaaf406d1cf903d34a2fb175d947b7b9fd">rc_vector_zeros</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with zeros.  <a href="#gaaf406d1cf903d34a2fb175d947b7b9fd">More...</a><br /></td></tr>
<tr class="separator:gaaf406d1cf903d34a2fb175d947b7b9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c2070da0f5b606113068dabcf64606"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga93c2070da0f5b606113068dabcf64606">rc_vector_ones</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga93c2070da0f5b606113068dabcf64606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with ones.  <a href="#ga93c2070da0f5b606113068dabcf64606">More...</a><br /></td></tr>
<tr class="separator:ga93c2070da0f5b606113068dabcf64606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61b0bc1f274f79017342393a2cf4c768"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga61b0bc1f274f79017342393a2cf4c768">rc_vector_random</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:ga61b0bc1f274f79017342393a2cf4c768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with random numbers between -1.0 and 1.0.  <a href="#ga61b0bc1f274f79017342393a2cf4c768">More...</a><br /></td></tr>
<tr class="separator:ga61b0bc1f274f79017342393a2cf4c768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab26ea389839dc7cae224a3709316db03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#gab26ea389839dc7cae224a3709316db03">rc_vector_fibonnaci</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, int length)</td></tr>
<tr class="memdesc:gab26ea389839dc7cae224a3709316db03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and fills with Fibonnaci sequence.  <a href="#gab26ea389839dc7cae224a3709316db03">More...</a><br /></td></tr>
<tr class="separator:gab26ea389839dc7cae224a3709316db03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga31a8a6926c3eeabe915ea943976a2e0e">rc_vector_from_array</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, float *ptr, int length)</td></tr>
<tr class="memdesc:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes vector v and populates with values from specified array ptr.  <a href="#ga31a8a6926c3eeabe915ea943976a2e0e">More...</a><br /></td></tr>
<tr class="separator:ga31a8a6926c3eeabe915ea943976a2e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aade05352c44f0eed9835a2e555254f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga5aade05352c44f0eed9835a2e555254f">rc_vector_duplicate</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> a, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *b)</td></tr>
<tr class="memdesc:ga5aade05352c44f0eed9835a2e555254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates the contents of vector a and into a new vector b.  <a href="#ga5aade05352c44f0eed9835a2e555254f">More...</a><br /></td></tr>
<tr class="separator:ga5aade05352c44f0eed9835a2e555254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbd986c3f1759de97760c2e65245fc45"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#gafbd986c3f1759de97760c2e65245fc45">rc_vector_print</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:gafbd986c3f1759de97760c2e65245fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to stdout the contents of vector v in one line.  <a href="#gafbd986c3f1759de97760c2e65245fc45">More...</a><br /></td></tr>
<tr class="separator:gafbd986c3f1759de97760c2e65245fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ea0298241c1b0207aea04cd331041d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga6ea0298241c1b0207aea04cd331041d9">rc_vector_print_sci</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga6ea0298241c1b0207aea04cd331041d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints to stdout the contents of vector v in one line.  <a href="#ga6ea0298241c1b0207aea04cd331041d9">More...</a><br /></td></tr>
<tr class="separator:ga6ea0298241c1b0207aea04cd331041d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2a9764a948a56fae6d5f1897edf8562"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#gac2a9764a948a56fae6d5f1897edf8562">rc_vector_times_scalar</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v, float s)</td></tr>
<tr class="memdesc:gac2a9764a948a56fae6d5f1897edf8562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies every entry in vector v by scalar s.  <a href="#gac2a9764a948a56fae6d5f1897edf8562">More...</a><br /></td></tr>
<tr class="separator:gac2a9764a948a56fae6d5f1897edf8562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5553a660876a1576c0bd226e49608e68"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga5553a660876a1576c0bd226e49608e68">rc_vector_norm</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, float p)</td></tr>
<tr class="memdesc:ga5553a660876a1576c0bd226e49608e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p is any positive real value.  <a href="#ga5553a660876a1576c0bd226e49608e68">More...</a><br /></td></tr>
<tr class="separator:ga5553a660876a1576c0bd226e49608e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4b086af44400fa2fa56af2618bfe81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga3e4b086af44400fa2fa56af2618bfe81">rc_vector_max</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga3e4b086af44400fa2fa56af2618bfe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the maximum value in v.  <a href="#ga3e4b086af44400fa2fa56af2618bfe81">More...</a><br /></td></tr>
<tr class="separator:ga3e4b086af44400fa2fa56af2618bfe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5cf5dee22ee0807725e86463b3cb415"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#gaf5cf5dee22ee0807725e86463b3cb415">rc_vector_min</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:gaf5cf5dee22ee0807725e86463b3cb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the minimum value in v.  <a href="#gaf5cf5dee22ee0807725e86463b3cb415">More...</a><br /></td></tr>
<tr class="separator:gaf5cf5dee22ee0807725e86463b3cb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cc3db26b59dc0454321820bfd8c9384"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga0cc3db26b59dc0454321820bfd8c9384">rc_vector_std_dev</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga0cc3db26b59dc0454321820bfd8c9384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard deviation of the values in a vector.  <a href="#ga0cc3db26b59dc0454321820bfd8c9384">More...</a><br /></td></tr>
<tr class="separator:ga0cc3db26b59dc0454321820bfd8c9384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5787bffdc4620a44699a71cd496e7187"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga5787bffdc4620a44699a71cd496e7187">rc_vector_mean</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v)</td></tr>
<tr class="memdesc:ga5787bffdc4620a44699a71cd496e7187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean (average) of all values in vector v or -1.0f on error.  <a href="#ga5787bffdc4620a44699a71cd496e7187">More...</a><br /></td></tr>
<tr class="separator:ga5787bffdc4620a44699a71cd496e7187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga9d6baef58e77a3f6f17cd76d3967dcce">rc_vector_projection</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> e, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p)</td></tr>
<tr class="memdesc:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector p with the projection of vector v onto e.  <a href="#ga9d6baef58e77a3f6f17cd76d3967dcce">More...</a><br /></td></tr>
<tr class="separator:ga9d6baef58e77a3f6f17cd76d3967dcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca02db03974e50fa834e3512415991bb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#gaca02db03974e50fa834e3512415991bb">rc_vector_dot_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2)</td></tr>
<tr class="memdesc:gaca02db03974e50fa834e3512415991bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product of two equal-length vectors.  <a href="#gaca02db03974e50fa834e3512415991bb">More...</a><br /></td></tr>
<tr class="separator:gaca02db03974e50fa834e3512415991bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">rc_vector_cross_product</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *p)</td></tr>
<tr class="memdesc:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross-product of two vectors, each of length 3.  <a href="#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">More...</a><br /></td></tr>
<tr class="separator:ga01bee4c05bf391b3fb30b1b9fa8f7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c8a002edae139b24bde39eff021cf8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga2c8a002edae139b24bde39eff021cf8e">rc_vector_sum</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> *s)</td></tr>
<tr class="memdesc:ga2c8a002edae139b24bde39eff021cf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates vector s with the sum of vectors v1 and v2.  <a href="#ga2c8a002edae139b24bde39eff021cf8e">More...</a><br /></td></tr>
<tr class="separator:ga2c8a002edae139b24bde39eff021cf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vector.html#ga4af34fe82269a8a963c1a6b7850df8dc">rc_vector_sum_inplace</a> (<a class="el" href="structrc__vector__t.html">rc_vector_t</a> *v1, <a class="el" href="structrc__vector__t.html">rc_vector_t</a> v2)</td></tr>
<tr class="memdesc:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds vector v2 to v1 and leaves the result in v1.  <a href="#ga4af34fe82269a8a963c1a6b7850df8dc">More...</a><br /></td></tr>
<tr class="separator:ga4af34fe82269a8a963c1a6b7850df8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga356f39688934d6424182bfb27d60c5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga356f39688934d6424182bfb27d60c5e1">&#9670;&nbsp;</a></span>rc_vector_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrc__vector__t.html">rc_vector_t</a>  <a class="el" href="structrc__vector__t.html">rc_vector_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its contents. </p>
<p>Set and read values directly with this code: </p><div class="fragment"><div class="line">vec.d[position]=new_value; <span class="comment">// set value in the vector</span></div><div class="line">value = v.d[pos]; <span class="comment">// get value from vector</span></div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga033739cf97c12aa0d22e2a38cf658aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga033739cf97c12aa0d22e2a38cf658aa7">&#9670;&nbsp;</a></span>rc_vector_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> rc_vector_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0. </p>
<p>This is esssential for initializing vectors when they are declared since local variables declared in a function without global variable scope in C are not guaranteed to be zeroed out which can lead to bad memory pointers and segfaults if not handled carefully. We recommend initializing all vectors with this function before using rc_vector_alloc or any other function.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with no allocated memory and the initialized flag set to 0. </dd></dl>

</div>
</div>
<a id="ga11722701079a6c31a88c1b2b5535c034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11722701079a6c31a88c1b2b5535c034">&#9670;&nbsp;</a></span>rc_vector_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for vector v to have specified length. </p>
<p>If v is initially the right length then nothing is done and the data in v is preserved. If v is uninitialized or of the wrong length then any existing memory is freed and new memory is allocated, helping to prevent accidental memory leaks.</p>
<p>The contents of the new vector is not guaranteed to be anything in particular as it is allocated with malloc. Use rc_vector_zeros or rc_vector_ones if you require known starting values.</p>
<p>Returns 0 if successful, otherwise returns -1. Will only be unsuccessful if length is invalid or there is insufficient memory available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga866d0dd17fd2d052ffe0edb1ebbcf6ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga866d0dd17fd2d052ffe0edb1ebbcf6ca">&#9670;&nbsp;</a></span>rc_vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for vector v. </p>
<p>Also sets the length and initialized flag of the <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct to 0 to indicate to other functions that v no longer points to allocated memory and cannot be used until more memory is allocated such as with rc_vector_alloc or rc_vector_zeros. Returns 0 on success. Will only fail and return -1 if it is passed a NULL pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gaaf406d1cf903d34a2fb175d947b7b9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf406d1cf903d34a2fb175d947b7b9fd">&#9670;&nbsp;</a></span>rc_vector_zeros()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_zeros </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with zeros. </p>
<p>uses calloc to allocate new memory. Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga93c2070da0f5b606113068dabcf64606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c2070da0f5b606113068dabcf64606">&#9670;&nbsp;</a></span>rc_vector_ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_ones </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with ones. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga61b0bc1f274f79017342393a2cf4c768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61b0bc1f274f79017342393a2cf4c768">&#9670;&nbsp;</a></span>rc_vector_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with random numbers between -1.0 and 1.0. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gab26ea389839dc7cae224a3709316db03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab26ea389839dc7cae224a3709316db03">&#9670;&nbsp;</a></span>rc_vector_fibonnaci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_fibonnaci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and fills with Fibonnaci sequence. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga31a8a6926c3eeabe915ea943976a2e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a8a6926c3eeabe915ea943976a2e0e">&#9670;&nbsp;</a></span>rc_vector_from_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_from_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes vector v and populates with values from specified array ptr. </p>
<p>Any existing memory allocated for v is freed if necessary to avoid memory leaks. It is not necessary to call rc_alloc_vector before this. This is generally used when the user has an existing array of data and wants to use it with other math functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>pointer to array to read values from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of vector to allocate memory for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="ga5aade05352c44f0eed9835a2e555254f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aade05352c44f0eed9835a2e555254f">&#9670;&nbsp;</a></span>rc_vector_duplicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_duplicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates the contents of vector a and into a new vector b. </p>
<p>Simply making a copy of an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct is not sufficient as the <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct simply contains a pointer to the memory allocated to contain the contents of the vector. rc_vector_duplicate sets b to be a new <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> with a pointer to freshly-allocated memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Vector to be duplicated </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">b</td><td>pointer to new vector to be allocated and written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if successful, otherwise returns -1. </dd></dl>

</div>
</div>
<a id="gafbd986c3f1759de97760c2e65245fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbd986c3f1759de97760c2e65245fc45">&#9670;&nbsp;</a></span>rc_vector_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to stdout the contents of vector v in one line. </p>
<p>This is not advisable for extremely long vectors but serves for quickly debugging or printing results. It prints 4 decimal places with padding for a sign. We recommend <a class="el" href="group__vector.html#ga6ea0298241c1b0207aea04cd331041d9" title="Prints to stdout the contents of vector v in one line. ">rc_vector_print_sci()</a> for very small or very large numbers where scientific notation would be more appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga6ea0298241c1b0207aea04cd331041d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ea0298241c1b0207aea04cd331041d9">&#9670;&nbsp;</a></span>rc_vector_print_sci()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_print_sci </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints to stdout the contents of vector v in one line. </p>
<p>Like rc_vector_print but prints with scientific notation. This is not advisable for extremely long vectors but serves for quickly debugging or printing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="gac2a9764a948a56fae6d5f1897edf8562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2a9764a948a56fae6d5f1897edf8562">&#9670;&nbsp;</a></span>rc_vector_times_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_times_scalar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies every entry in vector v by scalar s. </p>
<p>It is not strictly necessary for v to be provided as a pointer since a copy of the struct v would also contain the correct pointer to the original vector's allocated memory. However, in this library we use the convention of passing an <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct or rc_matrix_struct as a pointer when its data is to be modified by the function, and as a normal argument when it is only to be read by the function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v</td><td>Pointer to user's <a class="el" href="structrc__vector__t.html" title="Struct containing the state of a vector and a pointer to dynamically allocated memory to hold its con...">rc_vector_t</a> struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>scalar multiplier</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success or -1 on failure. </dd></dl>

</div>
</div>
<a id="ga5553a660876a1576c0bd226e49608e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5553a660876a1576c0bd226e49608e68">&#9670;&nbsp;</a></span>rc_vector_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_norm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p is any positive real value. </p>
<p>Just like the matlab norm(v,p) function.</p>
<p>Most common norms are the 1 norm which gives the sum of absolute values of the vector and the 2-norm which is the square root of sum of squares. for infinity and -infinity norms see rc_vector_max and rc_vector_min</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Which norm to use. Positive real values only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector norm. Prints error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga3e4b086af44400fa2fa56af2618bfe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e4b086af44400fa2fa56af2618bfe81">&#9670;&nbsp;</a></span>rc_vector_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the maximum value in v. </p>
<p>The value contained in the returned index is the equivalent to the infinity norm. If the max value occurs multiple times then the index of the first instance is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the maximum value in v or -1 on error. </dd></dl>

</div>
</div>
<a id="gaf5cf5dee22ee0807725e86463b3cb415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5cf5dee22ee0807725e86463b3cb415">&#9670;&nbsp;</a></span>rc_vector_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index of the minimum value in v. </p>
<p>The value contained in the returned index is the equivalent to the -infinity norm. If the minimum value occurs multiple times then the index of the first instance is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index of the minimum value in v or -1 on error. </dd></dl>

</div>
</div>
<a id="ga0cc3db26b59dc0454321820bfd8c9384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cc3db26b59dc0454321820bfd8c9384">&#9670;&nbsp;</a></span>rc_vector_std_dev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_std_dev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the standard deviation of the values in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the standard deviation or prints and error message and return -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga5787bffdc4620a44699a71cd496e7187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5787bffdc4620a44699a71cd496e7187">&#9670;&nbsp;</a></span>rc_vector_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_mean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the mean (average) of all values in vector v or -1.0f on error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the mean (average) of all values in vector v or -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga9d6baef58e77a3f6f17cd76d3967dcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d6baef58e77a3f6f17cd76d3967dcce">&#9670;&nbsp;</a></span>rc_vector_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_projection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector p with the projection of vector v onto e. </p>
<p>p is resized appropriately and any exising memory is freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="gaca02db03974e50fa834e3512415991bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca02db03974e50fa834e3512415991bb">&#9670;&nbsp;</a></span>rc_vector_dot_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float rc_vector_dot_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the dot product of two equal-length vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the dot product, or prints and error message and returns -1.0f on error. </dd></dl>

</div>
</div>
<a id="ga01bee4c05bf391b3fb30b1b9fa8f7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01bee4c05bf391b3fb30b1b9fa8f7ff0">&#9670;&nbsp;</a></span>rc_vector_cross_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_cross_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cross-product of two vectors, each of length 3. </p>
<p>The result is placed in vector p and and any existing memory used by p is freed to avoid memory leaks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>resulting cross product</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="ga2c8a002edae139b24bde39eff021cf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c8a002edae139b24bde39eff021cf8e">&#9670;&nbsp;</a></span>rc_vector_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_sum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates vector s with the sum of vectors v1 and v2. </p>
<p>v1 and v2 must be of the same length. Any existing memory allocated for s is freed and lost, new memory is allocated if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s</td><td>output sum</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
<a id="ga4af34fe82269a8a963c1a6b7850df8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4af34fe82269a8a963c1a6b7850df8dc">&#9670;&nbsp;</a></span>rc_vector_sum_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rc_vector_sum_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrc__vector__t.html">rc_vector_t</a>&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds vector v2 to v1 and leaves the result in v1. </p>
<p>The original contents of v1 are lost and v2 is left untouched. v1 and v2 must be of the same length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">v1</td><td>User's vector struct, holds the result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>User's vector struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, otherwise -1. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
